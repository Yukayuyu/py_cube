;; -*- mode: org; eval: (company-mode 1); -*-
//Thinking in Java, by Bruce Eckel, 1033 pages
==============================================
* The common-error 
** the local variables is always not public;
[[./Cp8_ConstructorsWithoutArgument.java::5][Cp8_ConstructorsWithoutArguent::5]] 
==============================================
* The disadvantage of Java.
  1. "How compiler work" is just some heavy knowledge. Hard to debug (e.g. gbc binary walk style, or even compare to python.) 
  2. GUI/Simple math(arrays, matrix, calculation, statics) is hard to implement, compare to R, python.
  3. Since Java's performance heavily rely on Compiler/JVM's algorithm, the Legacy code shall be heavy. This increase the Long-term upgrade cost.
==============================================
//Mar 3, p0 ~ p33
* Chapter 2. Introduction to Objects.
Java 1. > C++ when objects are more "dynamic". e.g. handling data that with an always changing size. Reasons: variables declaration conventions (effect how to compile). (cpp automatic/scoped variables or static in size) vs (Java's convention, the dynamic approach, e.g. the heap).
  However the dynamic method requires more headers, hence slower.
  Cpp can use heap too. However needs manual order, to destory. While Java uses the GBC.

2. Exception cannot be ignored. Thus more robust in general

3. When dealing with concurrency, Language level, enables it to cross-platforming(or not because it's JVM lol) i.e. multi-threading. 
  Shared resources access: Lock->use->Released loop. SE5~ with lib support. (diff. with Golong)

//Mar 4th, ~p44
4. In Web senario. middleware a. processes client data, b. increases respond speed, c. more maintainable than changing client.
  To further reduce latency, use client-side programming. i.e. Common Gateway Interface (CGI)

  4.1 Most of the simple client-side programming could be implemented using plug-ins & scripting language. (e.g. js) However complex scripts might be messy since it is hard to catch error or debug.
  4.2 For more complicate usage (e.g. concurrency, database access, network programming, distributed computing), Java/.Net steps in via *applet* & *Java Web Start* :
    The applet might be considered as a specified tiny program(e.g. capture mouse click), which is pushed from server to client when necessary. However, since it depends on JRE(+-10MB), which needs to be manually downloaded, and was not included by default in the IE(MS counter part shall be .Net/C#). The usage was limited in Internet.
    In enterprise however, since client machine are configurable by system manager, the applet&JavaWebStart might be more cost-efficient, since it eliminate the needs to manually update client softwares(each push of the applet is the newest).
    In cross-platform cases, Java applet/JWS > .Net, for obvious reason. Though in enterprise all-clients-Windows case exists.
    In real world, cases depends on the Legacy code, and the cost of each solution.
    Server-side-programming, including text processing & database r/w, are traditionally implemented using Perl, Python, C++ ,.etc to create CGI programs. For complicated usage(supposely dynamic large data?), servlets/JSPs kicks in. In this scenario, Java wins by cross-platforming. (there're more)

* Chapter 3. Everything is an Object
To manipulate objects, C/C++ use &* pointers, which is treated as special objects that each refer to a position in the memory. As for Java, the process is automated, and Class.Obj refers to the object in the memory.
  String s;    create the pointer.
  new ...;  create a new object.
  //Hence, String s = "ab"; is the illegal cases in C/C++
  String s = new String("asdf"); create a new obj -> link it to a pointer.

** Storage Lives in:
  a. The registers.
  b. The stack.
    In RAM, but directly supported by the processor, via its stack pointer. The stack pointer moves down for new memory, moves up to release the memory. 2nd fastest(supposely because of the fixed pointer)
    Objs in the stack must be specified explicitly on its exact lifetime(and size?) when compiling, thus reduce its flexibility.
    Java can also create new obj in the stack, i.e. *Primitive Types*:
      Heap is inefficient for small variables.
      generate new variables and store it directly in the stack.
      *keywords: boolean, char(16 bits), byte(8bits), short(16bits), int(32bits), long(64bits), float(32bits), double(64bits), void*
      *wrappers: Boolean, Characer, Byte, Short, Integer, Long, Float, Double, Void*
      Autoboxing, Wrapper and Primitive Types:
        char c = 'x';    //Primitive Types c in stack
        Character ch = c;
        char d = ch;
  c. The heap.
    In RAM. Most Java objs lives in the heap. Does not require to specify the lifetime on compilation. Calling the "new" function on runtime allocates new heap for the new obj. And needs cleanup (GBC), hence slower.
  d. Constant storage.
    Constant values are hard coded since it never changes. Somecases in Read-Only-Memory(ROM). e.g. string pool.
  e. Non-RAM storage. 
    Data lives outside a program. e.g. Streamed objects & Persistent objects. (e.g. used in JDBC/Hibernation)

** Other datatypes: 
  High-precision numbers(Check later).
    BigInterger
    BigDecimal
  Arrays.
    > C++ in the sense that, 1. a Java array is guaranteed to be initilaized; 2. Java array has memory overhead & verify index on runtime, thus eliminated the risk of illegal r/w on memory outside of the array range. 

//Mar 5th, ~p51 
** Null pointer:
  //int[] anArray = {1, 2,..., 5};
  int[] nullArray;
  When pointer is declared without a referencing object, JAVA auto refer it to keyward *null*. When *null* is called, compilier throws an error.

** Obj lifespawn & GBC:
  *scope*
    {...{...}...}
    {int x=12;
      {int x=13; //Illegal in JAVA, though legal in C/C++
       String s = new String("13");
      }
    } 
   Java's *GBC* (on runtime) search in all obj created by *new*. Auto destory when out of the scope (cannot be referenced anymore).  
   While C++ GBC is hard coded.
 
** /Naming Conventions/
  https://en.wikipedia.org/wiki/Naming_convention_%28programming%29#Java
  | Class     | *UpperCamelCase*      |                                                                                                                              |
  | Methods   | *lowerCamelCase*      |                                                                                                                              |
  | Variables | *lowerCamelCase*      | should not start with '_' or '$'(instance variables). For temporary varialbes, (i j k) for integers, (c d e) for characters. |
  | Constants | *UPPERCASECHARACTERS* | should not start with digit                                                                                                  |

** class:
*** Default initial values for primitive types, *as members of a class*.
    | boolean | false    |                       |
    | char    | 'u\0000' | 16 bits = 2^16 = 16^4 |
    | byte    | (byte)0  | 8 bits = 1 byte       |
    | short   | (short)0 | 16 bits               |
    | int     | 0        | 32 bits               |
    | long    | 0L       | 64 bits               |
    | float   | 0.0f     | 32 bits               |
    | double  | 0.0d     | 64 bits               |

***  *importing packages/classes*
     import java.util.ArrayList; //java.util is a package
     import java.util.*; 
  
***  *static*
      1. for CONSTANTs, that one single instance used universally.
      2. for methods which are independent, to any other object instances of that class.
 //Mar 6th, ~p55 
*** *static* method create a fix entry point. Can be called withouout creating an object. 
    [[file:Cp3_Class.java::17][Cp3ClassStaticTest]]
    And for this reason (fixed entry point), the main{} has to be static.

//Mar 7th, ~p62 
** Javadoc (in case need more styles, use "doclets")
   *{>javadoc -d ./destination file}*
   [[./Cp3_Javadoc.java::3][Cp3_Javadoc]]
   1. Before the class/method
   2. more about @tags in *annotation*.
   3. some tags: @author, @version, @param, @return, @throws(check later), @deprecated  
      
      
//Mar 8th, ~p68 
* Chapter 4. Operators  
** *import static*
   [[file:Cp4_Operators.java][Cp4_Operators_import_statiic]]
   
** Something more about the *private, public, static* scopes.
   1. The meaning of private / public field shall be clear. 
    public class Person {
      public String name;
      private String count;
      modifier returnType nameOfMethod (Param List){
      //method body (could be used to modify the private variables)
      }
    }
   //in this case, use Person.method to interact with tthe private String.
   2. *static final* as const

//Mar 9, ~p79
** The *private class* / *inner class*
   Non-static variable cannot be referenced from a static context
   For detail see:
   [[https://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html][docs.oracle.come/innerclasses]] 
   Private inner class -> referenced as *new* instance in a *public method* of the class-> main{call class constructor -> call the method};
   
** comparison
   *equals()* (class java.lang.Object) 
   *x.equals(y)* returns true if and noly if x & y points to the same object.
   while as in String class, there's another equals() that compares string content if match.

** && || !

** Literals
   [[./Cp4_Literals.java][Cp4_Literals.java]]
   (byte) (short) / L / D / f
   0b / number / 0x / 0 
   Expoents: 1e-2d == 0.01; 1e1d == 10; 

** Bitwise Operators
   | AND | &           |
   | OR  | verticalBar |
   | XOR | ^           |
   | NOT | ~           |
   &=, |=, ^= are legitimate.
   Bitwise-NOT is illegit on *booleans*
   
** How to print the type of an primitive
   *Use autoboxing*
   Object o = x + c;
   System.out.println(o.getClass());
*** Note that (byte +,-,*,/,&,| byte) -> int
    [[./Cp4_Bitwise.java::10][Cp4_Bitwise]]
    To prevent register leak/overflow, and presumably increase effiency.
    Due to the definition of the operator, which for C# is defined in (ECMA-334). 
    
** Shift operators
   | signed extension   | >>, << |
   | Unsigned extension | >>>    |
   Note that since << cause overflow directly, <<< does not exist.
   char, byte, short auto promote to int. (to prevent "bits leak" in the x64 register)
   [[./Cp4_Bitwise.java::19][Cp4_Bitwise]] 
  
** Print Binary Strings
   Integer.toBinaryString();
   Long.toBinaryString();
   
//Mar 10, ~p100
** Ternary if-else operator
   boolean-exp ? ifTrueEvalFunction0 : ifFalseEvalFunction1; 
   static int ternary (int i){
     return i < 10 ? i * 100 : i * 10;
   }
** Casting operator
   [[./Cp4_Casting.java][Cp4_Casting.java]]
   double j = 1;
   int i = (int) j;
   (float format? IEEE 754, check later)
   Noted that the casting is not the same in C++;

** round() and int()
   java.lang.Math.round()

** no *sizeof()*
   size is hard coded into the compiler.
   
** *no warning on overflow*.
   int k = 2147483647;
   k * 4 == -4;

* Chapter 5, Controlling Execution
** if(boolean-statement)
     else if()
     else

** while(boolean-expression)
     statement

** do-while
   do
   while(boolean-expression);

** for(initialization; boolean-expression; step)
   | for (char i=0; i<10; i++) |
   | for (char c : Iterable)   |
   [[./Cp5_ControlFlow.java][Cp5_ControlFlow.java]]
** while(true) equals to for(;;) or for(;true;) 
** generate a list, (1, 10): //Java 8   
   [[./Cp5_ControlFlow.java::25][Cp5_ControlFlow.java]]
   import static java.util.stream.*;
   List<Integer> range = IntStream.rangeClosed(start, end)
    .boxed().collect(Collectors.toList());
     System.out.print(c + "");
   //In this case java seems quite tedious handling math.
   
** unconditional branching. return, break, continue
   *return*
   quit the current method.
   *break*
   break the for/while loop
   *continue*
   next loop
   
//Mar 11, ~p117
** "goto" - "label"
   the label better to be exactly before a control flow. 
   label1:
   outer-iter{
     lol:
     inner-iter{
       continue lol;
       continue label1;
       //...
       break label1;
     }
   }
   
** switch
   switch(integral-selector){
     case int-value1 : 
     case int-value2 : statement; //case 1 and 2 share an output.
                       break;
     case int-value3 : statement; 
                       break;
     //...
     default: statement; //execute default if no match.
   }
     
* Chapter 6, Initialization & Cleanup
  //The Cp5_ is a joke. or a simple mistake.
** Constructor 
   Same name as the class
** Method overloading
   [[./Cp5_Overloading.java][Cp5_Overloading.java]]

** this
   this refers back to object.
   [[./Cp5_This.java::3][Cp5_This.java]] 
   *used often in a returns clause.* 
   *to pass objects around(separate implementation with object, i.e. to call methods in other classes)*
   C increment(){ //C is the class. since "return this" returns an obj.
     i++; return this;
   }
   
//Mar 12th, ~p135
   Also can call constructors from constructors. Once. Or use this.s = value; to modify class variable.

** Cannot call non-static methods from inside static methods. 

** Garbage Collection & Finalization 
   finalize(); //is just a mark, mark object for next garbage collection. Different with the /Distructor/ from C++
   Need to free() if used malloc() native function.
   Not reliable.
   
  *Avoid Finalizers* check out <Effective Java> later.
  try{//methods}
  finally{super.finalize()}
  
  *used to catch error e.g. obj not complete processed be thrown to gbc*
  protected void finalize(){
    if(flag)
      System.out.println("error msg.");
    super.finalize() //Call the base class finalizer
  }
*** GBC implementation
    1. reference-counting (simple, slow, inefficient)(when reference count==0 or null(out of scope), GBC. In circularly referencing cases, trash can have count greater than 0)
    2. Trace from static objects on the stack / in the static storage. 
       a. Hence, GBC might /stop-and-copy/, cp all live objects and pack them to new heap, thus free the desolated ones.
          it also create a map of new pointers and the old. correct when during the walk.
       b. when progn becomes stable, GBC uses /mark-and-sweep/, (slow but efficient in little to no garbage scenario. Prevent moving memory around.
    3. for big trunks / small temporary objects, use the *reference-counting* (generation-count), as well as *stop-and-copy*. 
       if all objects become long-lived, GBC proceed to *mark-and-sweep*.
       if fragments becomes an issue, GBC proceed to *stop-and-copy* again.
       
** the JIT implementation
    a JIT compiler partially or fully interpreted a code to native machine code so what does not rely on JVM interpretation.
    However, take compile time, and memory for the extra machine code, which decrease speed if cause paging.
    Or alternativly, /lazy evaluation/, JIT compile only when necessary.

** Member Initialization
   [[./Cp5_Initialize.java][Cp5_Initialize.java]]
   Every primitive field in a *Class* is automatically initiated. 
   
   Ways to specify initialize value, include the followings, Different from C++
   *specify when initialize*
   public class C{
     int i = 10;
     char c = 'c';
   }
   //Trivia in forward referencing
   public class MethodInit2
     //! int j = g(i); //illegal
     int i = f(); //legal
     int f() {return 10;}
     int g(int n) {return n;}
   }
   
   *objects within a class might get initialized multiple times, to guarantee proper initialization*
   e.g. If, in an overload method, an object is not initialized.
   
   *static* cannot be used on local variables, only applies to fields.
   The static object is initialized only once, when the obj is first called.
   public class C{
     static int i;
     static {
       i = 47;
     }
   }

** Array initialization   
   indexing operator [];
   int[] a1;
   int a1[]; //C++ style
   int[] a1 = {1, 2, 3, 4, 5};
   int[] a2;
   a2 = a1; //Only changes the pointer. 
   //So a2 change affects a1...
   [[./Cp5_Array.java][Cp5_Array.java]]
   
   when size unknown, use the *new* keyword:
   int[] a;
   a = new int[the_Length];
   //or
   int[] a = new int[the_Length];
`
//Mar 15, ~p137
*** Array grammar meaning  
    | int[] a1              | allocate enough memory for the *pointer*, to a primitive array       |
    | int[] ai = new ...    | primitive array, value initialized to default values. i.e. 0         |
    | //                    |                                                                      |
    | Integer[] a = new ... | non-primitive array, create a *list of pointers* with no real values |
    [[./Cp5_ArrayLoop.java][Cp5_ArrayLoop.java]]
//Mar 16.
//Mar 17, ~p
*** Variable argument lists, multiple args processing
    [[./Cp5_VarArgs.java][Cp5_VarArgs.java]]
    //0 or more parameters, "..."
    //[[https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs][docs.oracle.com: Arbitrary Numbers of Arguments]]
    [[./Cp5_VarArgs2.java][Cp5_VarArgs2.java]]
    //Better to use only 1 Varargs List when overloading.
    [[./Cp5_VarArgsOverloading.java][Cp5_VarArgsOverloading.java]]
    and when an constructor is used, the default constructor is nullified. So be aware of the f() situation
//Mar 17, ~p140
** Enumerated types
   the *enum* keyword.
   [[./Cp5_Enum.java][Cp5_Enum.java]]
   [[./Cp5_Spiciness.java][Cp5_Spiciness.java]]
   //the keyword creates some default methods.
   //which include toString(), ordinal()

* Non-static variable cannot be referenced from a static context   
   *The Solution*:
     class method{
       public static void main(String[] args){
         method mypgn = new method();
	 mypgn.start();
       }
       void start(){}
     }
   //Literally, call *new* only on the main class.?
   //And use only the methods of the main classs.?
   //in Cp7_PackageRun.java, we can see a resolve, by simply create a new instance of the non-static class.
   //then call the method of the instance.
   [[./Cp7_PackageRun.java::6][Cp7_PackageRun.java::6]]
   [[./Cp5_Burrito.java][Cp5_Burrito.java]]
   [[./Cp7_Private.java][Cp7_Private.java]]

* Chapter 7, Access Control
  *Public, protected, package access, private*
** package: the library unit
   package access.mypackage; //Should be in .../access/mypackage/ClassName.java
   import access.mypackage;
   [[./Cp7_Package_Class.java][Cp7_Package_Class.java]] //The package java file is supposed to be in the destination folder.
   [[./Cp7_PackageRun.java::6][Cp7_PackageRun.java::6]]
   //Note the path. and java's CLASSPATH env variable. echo $CLASSPATH, which is normally the current folder.

*** Collisions
    the Collisions happens when trying to *new* a classname which is collided.
    Could be avoided by stating the full path, say java.util.Vector v, instead of Vector v.
*** Custom tool library
    //However in order to use that, the main package structure shall remain unchanged.
    //Which require some work.
    //However, this should be considered a way to write all data structures, sorting, etc.

*** Use imports to change behavior.
    *alike C's conditional compilation*
    can be used in such as debugging code.
    Two packages, *debug* and *debugoff*
    
//Mar 18, ~p152
** Java Access specifiers
*** Package access
   |                | Class | Package | Subclass(same pkg) | Subclass(diff pkg) | World |
   | Public         | +     | +       | +                  | +                  | +     |
   | protected      | +     | +       | +                  | +                  |       |
   | package access | +     | +       | +                  |                    |       |
   | private        | +     |         |                    |                    |       |
  
  *private*
  //private is import especially when multithreading.
  [[./Cp7_Private.java][Cp7_Private.java]]
  //getter/setter
  private String Xxx
  public String getXxx(){
    return XXX;
  }
  public String setXxx(String name){
    this.XXX = name;
  }

  *protected*
  //protected is to deal with inheritance.

  *default*
  //default package. i.e. classes in the same directory.

*** Interface and implementation
    *encapsulation*
    //convention: public at top.

    *Class level control*
    //Since a class cannot be private or protected, in case that want to limit class access,
    //use a private constructor. and a static method to call it.
    *method1* //useful if extra process needed, when creating an instance. Say a count.
    class Soup1 {
      private Soup1(){}
      public static Soup1 makeSoup(){
        return new Soup1();
      }
    }
    *method2* //a *design pattern*, <<Thinking in Patterns>>. It only allows one single object to be created.
    class Soup2 {
      private Soup2(){}
      //the "Singleton" pattern
      private static Soup2 ps1 = new Soup2(); 
      public static Soup2 access(){
        return ps1;
      }
      public void f(){}
    }

* Chapter 8, Reusing Classes
** Composition syntax
   in the book section, the code overwrited non-primitive object's *toString()* method.
   [[./Cp8_ToString.java][Cp8_ToString.java]]
   
//Mar 19, ~p168
** Inheritance syntax
   class sub-class extends super-class{}
   //if constructor *without* arguments.
   //the constructor will be called outward.
** Constructors without argument   
   [[./Cp8_ConstructorsWithoutArgument.java][Cp8_ConstructorsWithoutArguent]]

** Constructors with argument
   *super*
   [[./Cp8_Super.java::20][Cp8_Super.java::20]]
   //The *super* is just like *this*
   //super.methodA(); to call methodA() in super.
   
** Delegation
   public class SpaceShipControls{
     void up(int v){}
   }
   //delegation
   public class SpaceShip extends SpaceShipControls
     {public void up (int v){controls.up(v)}
   }

** Guaranteeing proper cleanup
   //If cleanup is necessary,
   //use 
   try{
     //...
   } finally {
     x.disposeFunction();//...
   }

** Name hiding @Override
   //To prevent unintentionally overloading in sub-classes.
   //Use the annotation. after Java SE5
   [[./Cp8_Override.java][Cp8_Override.java]]
   
//Mar 21, ~179
** protected
   [[./Cp8_Protected.java][Cp8_Protected.java]] 
   //the private field cannot be accessed even in sub-classes.
   //private field using set/get method.
   // *However a new private static int call with the same name will not override* see line 24

** Upcasting
   class Instrument {
     public void play(){}
     static void tune(Instrument i){
       // ...
       i.play();
     }
   }
   public class Wind extends Instrument{
     public static void main(String[] args){
       Wind flute = new Wind();
       Instrument.tune(flute); //Upcasting
     }
   }

   //Ask: do I need upcasting.
   //Upcasting(inheritance) or Composition?
   //in Polymorphism.

** *Final*
   Either a *compile-time constant* that won't ever change.
   Or can be a value initialized at run time that you don't want changed. (?) 
   
   *static final* has only one picece of storge that cannot be changed.
   //Naming convention: static final *ALL_CAPS_WITH_UNDERBARS*
   
   *final* primitive cannot be changed.
   *final* pointer cannot be pointing to other objects. Though the objects can be modified.
   [[./Cp8_Final.java][Cp8_Final.java]]
   
** Blank finals
   [[./Cp8_Final.java::8][Cp8_Final.java::Line8]]
   
** final argsList
   void f(final int i), then {i++} becomes illegal.
   //primaily used to pass data to anonymous inner classes.
   
** When to use *final methods*
   1. Only use it to *prevent inhiritage / override.*
   2. (Deprecated, esp. after the *Hotspot* engine) Before Java SE 5/6, increase efficiency in some situations. When compile, invoke *inline calls*, which replace the method call with a copy of the actual code. As a result, the overhead is eliminated.
   [[./Cp8_FinalMethods.java][Cp8_FinalMethods.java]]
   
** final classes
   cannot be inherited (extended).
   1. for Design reason.
   2. for Security reason.

*** the demerit of final.
    the Java 1.0/1.1 *Vector* class's methods are all final, which is bad. Due to:
    1. eliminated the possibility of overriding. e.g. the *Stack* inherit from *Vector*.
    2. inefficient when dealing with *Concurrency*. Because import methods, e.g. addElement(), elementAt(), are all synchronized. 
     
** Initialization and class loading
   different from C++, in Java, the static field's order does not matter.
   The loading start whenever a static member is accessed. 
   All constructors are by default static.
   So when a new constructor is called, the class code is loaded.
   Loading also happens when other static methods or field is called.
   And the initialization happends only once.

//Mar 27, ~p189
** Initialization with inheritance
   [[./Cp8_ConstructorsWithoutArgument.java::5][Cp8_ConstructorsWithoutArguent::5]]
   //Mind the Order. 
   [[./Cp8_CompileOrder.java][Cp8_CompileOrder.java]]
   
   1. The main function first
   2. The constructor, parents first
   3. other fields are load on call.
   //The behavoir varies, depends on compiler versions.
   
* Chapter 9, Polymorphism
  *decoupling different types*
  This is also called *dynamic binding, or late binding, or run-time binding*
  
** Upcasting
   [[./Cp9_PolyUpcasting.java][Cp9_PolyUpcasting.java]]
   *Once override, the Super method cannot be called. Any call would redirect to the method in the sub-class.*
   
** Binding
   [[./Cp9_PolyUpcasting.java::21][Cp9_PolyUpcasting.java::21]]
   //tune(Instrument i); How compiler knows the right class to point to?
*** Binding
    *dynamic binding, or late binding, or run-time binding*
    //in contract, C only have early binding
    All methods in JAVA are latebinding.
    Except static, final(or private which is implicitly final)
    
    So the *final* call turn off dynamic binding, thus prevent method being overridden.
    
*** Producing the right behavior
    //Shape-Circle situation
    *Shape s = new Circle();* 
    s.draw(); //Circle.draw() will be called.
    //And s.getClass() returns "Circle"
    [[./Cp9_Shape.java][Cp9_Shape.java]]
    //However, if a new method is decleared in sub-class, it may not behave as expected.
    //The base class must have all methods/interfaces

*** Pitfall: fields and static method
    [[./Cp9_PolyPitfall.java][Cp9_PolyPitfall.java]]
    *static field should be accessed in a static way*
    //Avoid this:
    //Super sup = new Sub();
    //sup.function();
    //When function is called:
    //1. check if the f() is overrided. Execute the overrided version.
    //2. The function is hard-coded in the Sub .class file. Hence it uses that namespace. 
    //3. While the static field, doesn't change. So sup.i returns base While the static field, doesn't change. So sup.i returns base static vWhile the static field, doesn't change. So sup.j returns base static value.lue.
    
*** Behavior of polymorphic methods inside constructor
    //Inheritance. Just like the *constructors*. 
    //If not default(gbc), remember the *base-class* version. i.e. the *super* version.
    //Othewise the super part could not be properly set-up/clean-up.
    //practically used in *shared objects*
    [[./Cp9_Operators2.java][Cp9_Operators2]]
//Apr 4, p211

*** Covariant return types
    //Should be samed as the section above. sup sub01 behavior different before Java SE5.

** Designing with inheritance
   //When to avoid using polymorphism.
   //Better to *use composition first* since it is more flexible.
   //the *"State"* design pattern.
   [[./Cp9_State.java][Cp9_State.java]]
   
   
*** Substitution vs Extension
    //A clear way to use inheritance(or *polymorphism*), is when "pure" inheritance happens.
    //That is, only methods already decleared are overridden, no more new methods are included.
    //Extends is useful, but in the following case the poly cannot access new methods in child.
    [[./Cp9_Extends.java::17][Cp9_Extends.java::17]]

** *ClassCastException*, when error in downcasting.
   // *runtime type identification(RTTI)*
   [[./Cp9_RTTI.java::29][Cp9_RTTI.java::29]]
   //baseClass x = new baseClass();
   //In this case x cannot be downcast

* Chapter 10, Interfaces
** Abstract classes and methods
   [[./Cp9_PolyUpcasting.java][Cp9_PolyUpcasting.java]]
   //The methods within the Instrument class is always dummy;
   //So the code can be wrote that, when those methods are called, generate errors;
   //But that requires run-time debugging.
   //In order to detect those error in compile time, use *abstract* keyword.
   *abstract void f();*
   | 1. abstract methods must be within abstract classes.      |
   | 2. abstract classes *could* contain non-abstract methods. |
   //the keyword prevent user from creating *new* object of that class directly.
   rewind: Cp7 Access Control:
   package com.package; //should be in .../com/package/ClassName.java
//Apr 6th, ~p220

** Interface
   //The *interface* keyword defines a completely abstract class.
   //In some other languages, this is called a "protocol"
   //Fields in an interface are implicitly *static* and *final*.
   [[./Cp10_Interface.java][Cp10_Interface.java]]
   
   | 1. All methods in an Interface are implicitly *public* only. | //void toString(); 
   | 2. The fields in an Interface is not implemented.            |
//Apr 9th, ~p225   

** *Complete decoupling*
   //When sub-function take different type of input, it does not Override super.
   [[./Cp9_Extends.java][Cp9_Extends.java]]
   class Processor {
     public String name(){ return getName(); }
     Object process(Object input) { return input; }
   }

   class Upcase() extends Processor { //body }

   public class Apply{
     public static void process(Processor p, Object s){ //p must be in a sub-class of class Processor.
       System.out.println(p.process(s));
     }
     public static void main(String[] args){
     process(new Upcase(), s);
     }
   }
   //When a Waveform which is a new package comes in, it cannot be used by Apply directly,
   //Since it is not a sub-class of class Processor.
   //The Processor and the Apply class are Not as decoupled.
   //Use interface to complete decouple as follows:

   public interface Processor {
     public String name();
     Object process(Object input);
   }

   class Upcase() implement Processor { //body }

   public class Apply{
     public static void process(Processor p, Object s){ //p could comes from anywhere outside the package.
       System.out.println(p.process(s));
     }
     public static void main(String[] args){
     process(new Upcase(), s);
     Waveform w = new Waveform();
     Apply.process(new FiterAdapter(new LowPass(1.0)), w); //And it could be more flexible.
     }
   }
   //Conclusion: Interface is more global, more flexible than an abstract class.

** "Multiple inheritance" in Java.
   //Interface is for *to upcast to more than one base type*.
   //Only 1 super class is allowed using *extends*
   //While Multiple interfaces are allowed using *implements*
   //implement vs abstract
   //1. use interface whenever can, whenever abstraction can be done without explicitly stating the function body or var.
   //2. to prevent client programming to new an "empty" object.
   
** Extending an interface with inheritance
   interface Monster{
     void meenace();
   }
   interface DangerousMonster extends Monster{
     void destroy();
   }
   interface Lethal {
     void kill();
   }
   interface Vampire extends DangerousMonster, Lethal {
   void drinkBlood();
   }
   //provide easy extenability

** Name collisions when combining interfaces
   class C{ public int f(){return 1}; }
   interface I { void f(); }
   //! C5 extends C implements I ; //error
   //return type different cannot differ methods away.
   // *Avoid same method names in different Interfaces.*

** Adapting to an interface
   //Scanner Java SE5 class.
   //by implementing method "read()", it is applicable to any existing class.

** Fields in interfaces 
   //Before Java SE5, the *enum* did not exist.
   //Hence:
   public interface Months{
     int
       JANUARY = 1, FEBRBUARY = 2, MARCH = 3,
       APRIL = 4, MAY = 5, JUNE = 6, JULY =7,
       AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
       NOVEMBER = 11, DECEMBER =12;
   }
   [[./Cp10_Months.java][Cp10_Months]]
   [[./Cp10_InterfaceAsEnum.java][Cp10_InterfaceAsEnum]]
   //Fileds cannot be *blank finals*

//Apr 13th, ~p236
** Nesting interfaces
   //It's a feature.

** Interfaces and factories
   // *Factory Method* designing pattern produce objects thta fit the interface.
   //commonly used in building *framework*.
   //More elegent using innerclass.
   
** Summary
   //Abstraction should be motivated by a real need.
   //Interfaces should be something that I refactor to when necessary, but not everywhere.
   //A guidline might be to *prefer classes over interfaces*, and use interface only when clearly necessary.

* Chapter 11, Inner Classes
  //Allow code to be more elegant and clear.
  //The difference against normal classes.
  | 1. names are nested within the parent                     |
  | 2. it can be written to linked to its *enclosing object*. |
  [[./Cp11_Selector.java][Cp11_Selector]] 
  //theSelector selector = sequence.selector();
  
** Using .this and .new
   [[./Cp11_DotNewThis.java][Cp11_DotNewThis]]
   public Cp11_DotNewThis getOuter() {
       return Cp11_DotNewThis.this;
   }
   dnI.getOuter().thisIS();
   
** Inner classes and upcasting
   //Could be used to hide implementations.
   //Since only Innner classes could be private or protected.

** Inner classes in methods and scopes
   //2 reasons for using the inner classes.
   | 1. to implement a a interface and returns a reference.             |
   | 2. as an assistant class locally, while solving a complex problem. |

   if(b){class x{//body, encapsulation & getter;}} 
   //then the code is not accessable outside the scope.
   
** ? Anonymous inner classes
   [[./Cp11_AnonymousInner.java][Cp11_AnonymousInner]]
   
** ? Factory Method revisited

** ? Nested classes

** Classes inside interfaces p257
   public interface C{
   void howdy();
   class Test implements C{
     System.out.println("Howdy");
   }
   public static void main(String[] args){
     new Test().howdy();
   }
}
   //as a static class. but nested. if inside a public class C, compiled as file: C$Tester, which could be deleted when packaging.

** Reaching outward from a multiply nested class.
   // *inner class object could call outer class private functions.*

** Why inner classes?
   //Must use: When multiple *abstract class* is wanted, to be extend.
   //Features: 
     //Each inner can *independently* inherit from an implementation.
       +Which means different implementations is possible within a single parent class.
       +Its creation not strictly tied to outer-class object. 
       +Which then provide better orginaziton. (The Sequence does not have to be a Selector. [[./Cp11_Selector.java][Cp11_Selector]])

#+NAME: multiple abstract class extensions
#+HEADERS: :classname C
#+BEGIN_SRC java
class ParentClass {} 
abstract class absC{
  void f(){
    System.out.println("absC.f");
  }
}
class Z extends ParentClass {
  absC makeC() {
    return new absC (){ 
      @Override
      void f() {
        System.out.println("absC.f.implement");
      }
    };
  }
} //anonymous inner class as an implementation
public class C{
  public static void main(String[] args){
    //! absC x = new absC(); //absC is abstract; cannot be instantiated
    Z z = new Z();
    z.makeC().f();
  }
}
#+END_SRC

#+RESULTS: multiple abstract class extensions
: absC.f.implement


** Closures & callbacks
   A *closure* is a callable object that retains information from the scope in which it was created.
     i.e. an inner class can manipulate private parameters in its parent class.

*** *callbacks* function implementation using inner class
    [[./Cp11_Callback.java][Cp11_Callback]]
#+NAME: Callback
#+HEADERS: :classname Cp11_Callback
#+BEGIN_SRC java
private class Closure implements Incrementable {
    public void increment() {
        Callee2.this.increment();
    }
}

Incrementable getCallbackReference() {
    return new Closure();
}

class Caller {
    //body...,
    //1.constructor with *Closure()* Object reference.
    //2.ref.increment() -> void go(){}
}
public class Cp11_Callback{
    public static void main(String[] args){
        Callee2 c2 = new Callee2();
        Caller caller = new Caller(c2.getCallbackReference());
        caller2.go();
    }
}
#+END_SRC

#+RESULTS: Callback
| 1 |
| 2 |

//It turned this.increment() into an Incrementable object.

** ? Inner classes & control frameworks
   
** ? Inheriting from inner classes
   //The super constructor must be explicitly called 
#+NAME: InheritInner
#+HEADERS: :classname InheritInner
#+BEGIN_SRC java
class A{
    class AInner { 
        int i;
        AInner(){
            i = 1;
            System.out.println("hi");
        }
    }
}
public class InheritInner extends A.AInner{
    //! InheritInner(){}
    InheritInner(A x){
        x.super(); //Though counter intuitive.
    }
    public static void main(String[] args){
        A xa = new A();
        InheritInner xaa = new InheritInner(xa);
        System.out.println(xaa.i);
        A.AInner xb = xa.new AInner();
        System.out.println(xb.i);
    }
}
#+END_SRC

#+RESULTS: InheritInner
| hi |
|  1 |
| hi |
|  1 |

** ? Local inner classes

* Chapter 12, Holding Your Objects (Container basic)
** Generics and type-safe containers
   [[./Cp12_ArrayListWithoutGeneric.java][Cp12_ArrayListWithoutGeneric]]
   [[./Cp12_ArrayListWithGeneric.java][Cp12_ArrayListWithGeneric]]
   //the ArrayList<Generic(class)> can also upcast, take sub-class Objects.
   //for(Apple c : apples)
         //loop body
** Basic concepts
   //Two very basic interfaces:
   1. Collection: a sequence of elements with rule(s) applied to them.
      + List: holds the order of elements inserted.
      + Set: cannot have duplicate elements
      + Queue: *produces* the elements in the order determined by a *queuing discipline*
   2. Map: a group of key-value object pairs, allowing value look-up with the key.
      + ArrayList: allows object look-up with *number*.
      + Map: allows look-up with *another object*. (also named as associatve array or a *dictionary*)
        
   //Upcasting also possible:
   List<Apple> apples = new ArrayList<Apple>();
   List<Apple> apples = new LinkedList<Apple>();
   //Though by upcasting, sub-type's specific functions might be lost.
   //e.g. TreeMap, LinkedList's functions that does not exist in Map, List.
   [[./Cp12_SimpleCollection.java][Cp12_SimpleCollection]]
   //0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
** Basic Methods; Adding groups of elements
   add(): ensures that this Collection contains the specified element.
   [[./Cp12_BasicMethods.java][Cp12_BasicMethods]]
   #+NAME: BasicMethods
   #+HEADERS: :classname 
   #+BEGIN_SRC java
   Collection<Integer> collection = new ArrayList<Integer>{Arrays.asList{1,2,3}}
   Collection<Integer> collection = new ArrayList<Integer>();
   Integer[] moreInts = {4,5,6};
   collection.addAll(Arrays.asList(moreInts)); //inferior
   Collections.addAll(collection, moreInts); //runs faster, hence the preferred approach
   #+END_SRC
   
   //the Arrays.asList() take a guess on type.
   [[./Cp12_AsListInference.java][Cp12_AsListInference]]
** Printing containers
   Arrays.toString()
   [[./Cp12_PrintingContainers.java][Cp12_PrintingContainers]]
   
#+NAME: PrintingContainers
#+HEADERS: :results table :classname PrintingContainers
#+BEGIN_SRC java
import java.util.*;

public class PrintingContainers {
    static Collection fill(Collection<String> collection) {
        collection.add("rat");
        collection.add("dog");
        collection.add("dog");
        return collection;
    }

    static Map fill(Map<String,String> map) {
        map.put("rat", "Fuzzy");
        map.put("dog", "Bosco");
        map.put("dog", "Spot");
        return map;
    }

    public static void main(String[] args) {
        System.out.println(fill(new ArrayList<String>()));
        System.out.println(fill(new LinkedList<String>()));
        System.out.println(fill(new HashSet<String>()));
        System.out.println(fill(new TreeSet<String>()));
        System.out.println(fill(new LinkedHashSet<String>()));
        System.out.println(fill(new HashMap<String,String>()));
        System.out.println(fill(new TreeMap<String,String>()));
        System.out.println(fill(new LinkedHashMap<String,String>()));
    }
}

#+END_SRC

#+RESULTS: PrintingContainers
| [rat       | dog        | dog] |
| [rat       | dog        | dog] |
| [rat       | dog]       |      |
| [dog       | rat]       |      |
| [rat       | dog]       |      |
| {rat=Fuzzy | dog=Spot}  |      |
| {dog=Spot  | rat=Fuzzy} |      |
| {rat=Fuzzy | dog=Spot}  |      |

   //HashSet Fastest to retrieve. If inserting order matters, 
   //LinkedHashSet or TreeSet(slower).
*** interface List extends Collection, Iterable
    //the List interface.
    //promise to maintain elements in a particular sequence.
    //Two types of List:
     + ArrayList: excels at random accesing elements, but slower when inserting and removing elements in the middle of a list.
     + LinkedList: provides optimal sequential access, insertion and deletion in the middle are cheaper, in exchange of a larger feature set than the ArrayList.
           //Maybe related to Type Information.
           
    //Basic methods:
    Obj.
        add(Obj); add(positionInIndex, Obj); addAll(positionInIndex, Obj); get(id); 
        remove(theExactObjRef); removeAll(); indexOf(theExactObj); clear();
        subList(idStart, idEnd); contains(Obj); set(id, Obj); 

    Collections.
        sort(Obj); Collections.shuffle(Obj); 
        
*** interface Iterator
#+NAME: Cp12_Iterator 
#+HEADERS: :classname 
#+BEGIN_SRC java
List<Pet> pets = new ArrayList<Pet>(Arrays.asList("dog", "cat"));
Iterator<Pet> it = pets.iterator();
#+END_SRC
    //it.
         hasNext(); next(); remove(); 
         
*** ListIterator
#+NAME: Cp12_ListIterator 
#+HEADERS: :classname 
#+BEGIN_SRC java
List<Pet> pets = new ArrayList<Pet>(Arrays.asList("dog", "cat"));
Iterator<Pet> it = pets.listIterator();
#+END_SRC
    //it.
         hasNext(); next(); remove(); 
         
*** LinkedList 
#+NAME: Cp12_LinkedList
#+HEADERS: :classname 
#+BEGIN_SRC java
LinkedList<Pet> pets = new LinkedList<Pet>(Arrays.asList("dog", "cat"));
#+END_SRC
    //Obj.
          getFirst(); element(); peek(); removeFirst(); remove(); poll(); addfirst(); offer(); removeLast(); 

*** Stack
    //implemented using LinkedList.
    [[./Cp12_Stack.java][Cp12_Stack]]
    //To avoid conflict: must specify the whole path:
    //new java.util.Stack<String>();
    //new net.my.package.Stack<String>();
    
*** Set
    //
System.out.print
syso
* Chapter 13, Error Handling
* Chapter 14, Strings
* Chapter 15,
* Chapter 16,
* Chapter 17, Arrays
* Chapter 18, 
* Chapter 19, 
* Chapter 20, Annotations
* Chapter 21, Concurrency
