;; -*- mode: org; eval: (company-mode -1); -*-
//Thinking in Java, by Bruce Eckel, 1033 pages
==============================================
* TODO
  + Sorting
  + Interface
  + lambda
* The common-error 
** the local variables is always not public;
[[./Cp8_ConstructorsWithoutArgument.java::5][Cp8_ConstructorsWithoutArguent::5]] 

** the common discriptors:
    MethodType: '(' (FieldType)* ')' (FieldType | 'V')
    FieldType: PrimitiveType | ArrayType | ObjectType | *TypeExpr
    PrimitiveType: 'B' | 'C' | 'D' | 'F' | 'I' | 'J' | 'S' | 'Z'
    ArrayType: '[' (PrimitiveType | ArrayType | ObjectType)             ////]
    ObjectType: 'L' ClassName ';'
    *TypeExpr: TypeCarrier '/' (TypeOpName)? (';' | '[' (TypeArg)+ ']' )
    *TypeCarrier: FieldType | `L`
    *TypeOpName: '$' Identifier | ('L' ClassName) (';' '$' Identifier)?
    *TypeArg: FieldType | MethodType | NameArg | NumberArg
    *NumberArg: ('-')? DigitNotZero (Digit)* ';' | '0' ';'
    *NameArg: '$' Identifier ';'
    Identifier: (any character except '.' ';' '[' '/' '<' '>' ':')*      ////]
    
** Lexical Structure
*** Single quotes vs Double quotes
    //single quotes for literal char s, double quotes for literal String s, like so: char c = 'a'; String s = "hello"; They cannot be used any other way around
    | 's' | literal char s   |
    | "s" | literal String s |
*** Unicode Escapes
    [[./Cp0_UnicodeEscapes.java][Cp0_UnicodeEscapes]]
   
==============================================
* The disadvantage of Java.
  1. "How compiler work" is just some heavy knowledge. Hard to debug (e.g. gbc binary walk style, or even compare to python.) 
  2. GUI/Simple math(arrays, matrix, calculation, statics) is hard to implement, compare to R, python.
  3. Since Java's performance heavily rely on Compiler/JVM's algorithm, the Legacy code shall be heavy. This increase the Long-term upgrade cost.
==============================================
//Mar 3, p0 ~ p33
* Chapter 2. Introduction to Objects.
Java 1. > C++ when objects are more "dynamic". e.g. handling data that with an always changing size. Reasons: variables declaration conventions (effect how to compile). (cpp automatic/scoped variables or static in size) vs (Java's convention, the dynamic approach, e.g. the heap).
  However the dynamic method requires more headers, hence slower.
  Cpp can use heap too. However needs manual order, to destory. While Java uses the GBC.

2. Exception cannot be ignored. Thus more robust in general

3. When dealing with concurrency, Language level, enables it to cross-platforming(or not because it's JVM lol) i.e. multi-threading. 
  Shared resources access: Lock->use->Released loop. SE5~ with lib support. (diff. with Golong)

//Mar 4th, ~p44
4. In Web senario. middleware a. processes client data, b. increases respond speed, c. more maintainable than changing client.
  To further reduce latency, use client-side programming. i.e. Common Gateway Interface (CGI)

  4.1 Most of the simple client-side programming could be implemented using plug-ins & scripting language. (e.g. js) However complex scripts might be messy since it is hard to catch error or debug.
  4.2 For more complicate usage (e.g. concurrency, database access, network programming, distributed computing), Java/.Net steps in via *applet* & *Java Web Start* :
    The applet might be considered as a specified tiny program(e.g. capture mouse click), which is pushed from server to client when necessary. However, since it depends on JRE(+-10MB), which needs to be manually downloaded, nand was not included by default in the IE(MS counter part shall be .Net/C#). The usage was limited in Internet.
    In enterprise however, since client machine are configurable by system manager, the applet&JavaWebStart might be more cost-efficient, since it eliminate the needs to manually update client softwares(each push of the applet is the newest).
    In cross-platform cases, Java applet/JWS > .Net, for obvious reason. Though in enterprise all-clients-Windows case exists.
    In real world, cases depends on the Legacy code, and the cost of each solution.
    Server-side-programming, including text processing & database r/w, are traditionally implemented using Perl, Python, C++ ,.etc to create CGI programs. For complicated usage(supposely dynamic large data?), servlets/JSPs kicks in. In this scenario, Java wins by cross-platforming. (there're more)

* Chapter 3. Everything is an Object
To manipulate objects, C/C++ use &* pointers, which is treated as special objects that each refer to a position in the memory. As for Java, the process is automated, and Class.Obj refers to the object in the memory.
  String s;    create the pointer.
  new ...;  create a new object.
  //Hence, String s = "ab"; is the illegal cases in C/C++
  String s = new String("asdf"); create a new obj -> link it to a pointer.

** Storage Lives in:
  a. The registers.
  b. The stack.
    In RAM, but directly supported by the processor, via its stack pointer. The stack pointer moves down for new memory, moves up to release the memory. 2nd fastest(supposely because of the fixed pointer)
    Objs in the stack must be specified explicitly on its exact lifetime(and size?) when compiling, thus reduce its flexibility.
    Java can also create new obj in the stack, i.e. *Primitive Types*:
      Heap is inefficient for small variables.
      generate new variables and store it directly in the stack.
      *keywords: boolean, char(16 bits), byte(8bits), short(16bits), int(32bits), long(64bits), float(32bits), double(64bits), void*
      *wrappers: Boolean, Characer, Byte, Short, Integer, Long, Float, Double, Void*
      Autoboxing, Wrapper and Primitive Types:
        char c = 'x';    //Primitive Types c in stack
        Character ch = c;
        char d = ch;
  c. The heap.
    In RAM. Most Java objs lives in the heap. Does not require to specify the lifetime on compilation. Calling the "new" function on runtime allocates new heap for the new obj. And needs cleanup (GBC), hence slower.
  d. Constant storage.
    Constant values are hard coded since it never changes. Somecases in Read-Only-Memory(ROM). e.g. string pool.
  e. Non-RAM storage. 
    Data lives outside a program. e.g. Streamed objects & Persistent objects. (e.g. used in JDBC/Hibernation)

** Other datatypes: 
  High-precision numbers(Check later).
    BigInterger
    BigDecimal
  Arrays.
    > C++ in the sense that, 1. a Java array is guaranteed to be initilaized; 2. Java array has memory overhead & verify index on runtime, thus eliminated the risk of illegal r/w on memory outside of the array range. 

//Mar 5th, ~p51 
** Null pointer:
  //int[] anArray = {1, 2,..., 5};
  int[] nullArray;
  When pointer is declared without a referencing object, JAVA auto refer it to keyward *null*. When *null* is called, compilier throws an error.

** Obj lifespawn & GBC:
  *scope*
    {...{...}...}
    {int x=12;
      {int x=13; //Illegal in JAVA, though legal in C/C++
       String s = new String("13");
      }
    } 
   Java's *GBC* (on runtime) search in all obj created by *new*. Auto destory when out of the scope (cannot be referenced anymore).  
   While C++ GBC is hard coded.
 
** /Naming Conventions/
  https://en.wikipedia.org/wiki/Naming_convention_%28programming%29#Java
  | Class     | *UpperCamelCase*      |                                                                                                                              |
  | Methods   | *lowerCamelCase*      |                                                                                                                              |
  | Variables | *lowerCamelCase*      | should not start with '_' or '$'(instance variables). For temporary varialbes, (i j k) for integers, (c d e) for characters. |
  | Constants | *UPPERCASECHARACTERS* | should not start with digit                                                                                                  |

** class:
*** Default initial values for primitive types, *as members of a class*.
    | boolean | false    |                       |
    | char    | 'u\0000' | 16 bits = 2^16 = 16^4 |
    | byte    | (byte)0  | 8 bits = 1 byte       |
    | short   | (short)0 | 16 bits               |
    | int     | 0        | 32 bits               |
    | long    | 0L       | 64 bits               |
    | float   | 0.0f     | 32 bits               |
    | double  | 0.0d     | 64 bits               |

***  *importing packages/classes*
     import java.util.ArrayList; //java.util is a package
     import java.util.*; 
  
***  *static*
      1. for CONSTANTs, that one single instance used universally.
      2. for methods which are independent, to any other object instances of that class.
 //Mar 6th, ~p55 
*** *static* method create a fix entry point. Can be called withouout creating an object. 
    [[file:Cp3_Class.java::17][Cp3ClassStaticTest]]
    And for this reason (fixed entry point), the main{} has to be static.

//Mar 7th, ~p62 
** Javadoc (in case need more styles, use "doclets")
   *{>javadoc -d ./destination file}*
   [[./Cp3_Javadoc.java::3][Cp3_Javadoc]]
   1. Before the class/method
   2. more about @tags in *annotation*.
   3. some tags: @author, @version, @param, @return, @throws(check later), @deprecated  
      
      
//Mar 8th, ~p68 
* Chapter 4. Operators  
** *import static*
   [[file:Cp4_Operators.java][Cp4_Operators_import_statiic]]
   
** Something more about the *private, public, static* scopes.
   1. The meaning of private / public field shall be clear. 
    public class Person {
      public String name;
      private String count;
      modifier returnType nameOfMethod (Param List){
      //method body (could be used to modify the private variables)
      }
    }
   //in this case, use Person.method to interact with tthe private String.
   2. *static final* as const

//Mar 9, ~p79
** The *private class* / *inner class*
   Non-static variable cannot be referenced from a static context
   For detail see:
   [[https://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html][docs.oracle.come/innerclasses]] 
   Private inner class -> referenced as *new* instance in a *public method* of the class-> main{call class constructor -> call the method};
   
** comparison
   *equals()* (class java.lang.Object) 
   *x.equals(y)* returns true if and noly if x & y points to the same object.
   while as in String class, there's another equals() that compares string content if match.

** && || !

** Literals
   [[./Cp4_Literals.java][Cp4_Literals.java]]
   (byte) (short) / L / D / f
   0b / number / 0x / 0 
   Expoents: 1e-2d == 0.01; 1e1d == 10; 

** Bitwise Operators
   | AND | &           |
   | OR  | verticalBar |
   | XOR | ^           |
   | NOT | ~           |
   &=, |=, ^= are legitimate.
   Bitwise-NOT is illegit on *booleans*
   
** How to print the type of an primitive
   *Use autoboxing*
   Object o = x + c;
   System.out.println(o.getClass());
*** Note that (byte +,-,*,/,&,| byte) -> int
    [[./Cp4_Bitwise.java::10][Cp4_Bitwise]]
    To prevent register leak/overflow, and presumably increase effiency.
    Due to the definition of the operator, which for C# is defined in (ECMA-334). 
    
** Shift operators
   | signed extension   | >>, << |
   | Unsigned extension | >>>    |
   Note that since << cause overflow directly, <<< does not exist.
   char, byte, short auto promote to int. (to prevent "bits leak" in the x64 register)
   [[./Cp4_Bitwise.java::19][Cp4_Bitwise]] 
  
** Print Binary Strings
   Integer.toBinaryString();
   Long.toBinaryString();
   
//Mar 10, ~p100
** Ternary if-else operator
   boolean-exp ? ifTrueEvalFunction0 : ifFalseEvalFunction1; 
   static int ternary (int i){
     return i < 10 ? i * 100 : i * 10;
   }
** Casting operator
   [[./Cp4_Casting.java][Cp4_Casting.java]]
   double j = 1;
   int i = (int) j;
   (float format? IEEE 754, check later)
   Noted that the casting is not the same in C++;

** round() and int()
   java.lang.Math.round()

** no *sizeof()*
   size is hard coded into the compiler.
   
** *no warning on overflow*.
   int k = 2147483647;
   k * 4 == -4;

* Chapter 5, Controlling Execution
** if(boolean-statement)
     else if()
     else

** while(boolean-expression)
     statement

** do-while
   do
   while(boolean-expression);

** for(initialization; boolean-expression; step)
   | for (char i=0; i<10; i++) |
   | for (char c : Iterable)   |
   [[./Cp5_ControlFlow.java][Cp5_ControlFlow.java]]
** while(true) equals to for(;;) or for(;true;) 
** generate a list, (1, 10): //Java 8   
   [[./Cp5_ControlFlow.java::25][Cp5_ControlFlow.java]]
   import static java.util.stream.*;
   List<Integer> range = IntStream.rangeClosed(start, end)
    .boxed().collect(Collectors.toList());
     System.out.print(c + "");
   //In this case java seems quite tedious handling math.
   
** unconditional branching. return, break, continue
   *return*
   quit the current method.
   *break*
   break the for/while loop
   *continue*
   next loop
   
//Mar 11, ~p117
** "goto" - "label"
   the label better to be exactly before a control flow. 
   label1:
   outer-iter{
     lol:
     inner-iter{
       continue lol;
       continue label1;
       //...
       break label1;
     }
   }
   
** switch
   switch(integral-selector){
     case int-value1 : 
     case int-value2 : statement; //case 1 and 2 share an output.
                       break;
     case int-value3 : statement; 
                       break;
     //...
     default: statement; //execute default if no match.
   }
     
* Chapter 6, Initialization & Cleanup
  //The Cp5_ is a joke. or a simple mistake.
** Constructor 
   Same name as the class
** Method overloading
   [[./Cp5_Overloading.java][Cp5_Overloading.java]]

** this
   this refers back to object.
   [[./Cp5_This.java::3][Cp5_This.java]] 
   *used often in a returns clause.* 
   *to pass objects around(separate implementation with object, i.e. to call methods in other classes)*
   C increment(){ //C is the class. since "return this" returns an obj.
     i++; return this;
   }
   
//Mar 12th, ~p135
   Also can call constructors from constructors. Once. Or use this.s = value; to modify class variable.

** Cannot call non-static methods from inside static methods. 

** Garbage Collection & Finalization 
   finalize(); //is just a mark, mark object for next garbage collection. Different with the /Distructor/ from C++
   Need to free() if used malloc() native function.
   Not reliable.
   
  *Avoid Finalizers* check out <Effective Java> later.
  try{//methods}
  finally{super.finalize()}
  
  *used to catch error e.g. obj not complete processed be thrown to gbc*
  protected void finalize(){
    if(flag)
      System.out.println("error msg.");
    super.finalize() //Call the base class finalizer
  }
*** GBC implementation
    1. reference-counting (simple, slow, inefficient)(when reference count==0 or null(out of scope), GBC. In circularly referencing cases, trash can have count greater than 0)
    2. Trace from static objects on the stack / in the static storage. 
       a. Hence, GBC might /stop-and-copy/, cp all live objects and pack them to new heap, thus free the desolated ones.
          it also create a map of new pointers and the old. correct when during the walk.
       b. when progn becomes stable, GBC uses /mark-and-sweep/, (slow but efficient in little to no garbage scenario. Prevent moving memory around.
    3. for big trunks / small temporary objects, use the *reference-counting* (generation-count), as well as *stop-and-copy*. 
       if all objects become long-lived, GBC proceed to *mark-and-sweep*.
       if fragments becomes an issue, GBC proceed to *stop-and-copy* again.
       
** the JIT implementation
    a JIT compiler partially or fully interpreted a code to native machine code so what does not rely on JVM interpretation.
    However, take compile time, and memory for the extra machine code, which decrease speed if cause paging.
    Or alternativly, /lazy evaluation/, JIT compile only when necessary.

** Member Initialization
   [[./Cp5_Initialize.java][Cp5_Initialize.java]]
   Every primitive field in a *Class* is automatically initiated. 
   
   Ways to specify initialize value, include the followings, Different from C++
   *specify when initialize*
   public class C{
     int i = 10;
     char c = 'c';
   }
   //Trivia in forward referencing
   public class MethodInit2
     //! int j = g(i); //illegal
     int i = f(); //legal
     int f() {return 10;}
     int g(int n) {return n;}
   }
   
   *objects within a class might get initialized multiple times, to guarantee proper initialization*
   e.g. If, in an overload method, an object is not initialized.
   
   *static* cannot be used on local variables, only applies to fields.
   The static object is initialized only once, when the obj is first called.
   public class C{
     static int i;
     static {
       i = 47;
     }
   }

** Array initialization   
   indexing operator [];
   int[] a1;
   int a1[]; //C++ style
   int[] a1 = {1, 2, 3, 4, 5};
   int[] a2;
   a2 = a1; //Only changes the pointer. 
   //So a2 change affects a1...
   [[./Cp5_Array.java][Cp5_Array.java]]
   
   when size unknown, use the *new* keyword:
   int[] a;
   a = new int[the_Length];
   //or
   int[] a = new int[the_Length];
`
//Mar 15, ~p137
*** Array grammar meaning  
    | int[] a1              | allocate enough memory for the *pointer*, to a primitive array       |
    | int[] ai = new ...    | primitive array, value initialized to default values. i.e. 0         |
    | //                    |                                                                      |
    | Integer[] a = new ... | non-primitive array, create a *list of pointers* with no real values |
    [[./Cp5_ArrayLoop.java][Cp5_ArrayLoop.java]]
//Mar 16.
//Mar 17, ~p
*** Variable argument lists, multiple args processing
    [[./Cp5_VarArgs.java][Cp5_VarArgs.java]]
    //0 or more parameters, "..."
    //[[https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs][docs.oracle.com: Arbitrary Numbers of Arguments]]
    [[./Cp5_VarArgs2.java][Cp5_VarArgs2.java]]
    //Better to use only 1 Varargs List when overloading.
    [[./Cp5_VarArgsOverloading.java][Cp5_VarArgsOverloading.java]]
    and when an constructor is used, the default constructor is nullified. So be aware of the f() situation
//Mar 17, ~p140
** Enumerated types
   the *enum* keyword.
   [[./Cp5_Enum.java][Cp5_Enum.java]]
   [[./Cp5_Spiciness.java][Cp5_Spiciness.java]]
   //the keyword creates some default methods.
   //which include toString(), ordinal()

* Non-static variable cannot be referenced from a static context   
   *The Solution*:
     class method{
       public static void main(String[] args){
         method mypgn = new method();
	 mypgn.start();
       }
       void start(){}
     }
   //Literally, call *new* only on the main class.?
   //And use only the methods of the main classs.?
   //in Cp7_PackageRun.java, we can see a resolve, by simply create a new instance of the non-static class.
   //then call the method of the instance.
   [[./Cp7_PackageRun.java::6][Cp7_PackageRun.java::6]]
   [[./Cp5_Burrito.java][Cp5_Burrito.java]]
   [[./Cp7_Private.java][Cp7_Private.java]]

* Chapter 7, Access Control
  *Public, protected, package access, private*
** package: the library unit
   package access.mypackage; //Should be in .../access/mypackage/ClassName.java
   import access.mypackage;
   [[./Cp7_Package_Class.java][Cp7_Package_Class.java]] //The package java file is supposed to be in the destination folder.
   [[./Cp7_PackageRun.java::6][Cp7_PackageRun.java::6]]
   //Note the path. and java's CLASSPATH env variable. echo $CLASSPATH, which is normally the current folder.

*** Collisions
    the Collisions happens when trying to *new* a classname which is collided.
    Could be avoided by stating the full path, say java.util.Vector v, instead of Vector v.
*** Custom tool library
    //However in order to use that, the main package structure shall remain unchanged.
    //Which require some work.
    //However, this should be considered a way to write all data structures, sorting, etc.

*** Use imports to change behavior.
    *alike C's conditional compilation*
    can be used in such as debugging code.
    Two packages, *debug* and *debugoff*
    
//Mar 18, ~p152
** Java Access specifiers
*** Package access
   |                | Class | Package | Subclass(same pkg) | Subclass(diff pkg) | World |
   | Public         | +     | +       | +                  | +                  | +     |
   | protected      | +     | +       | +                  | +                  |       |
   | package access | +     | +       | +                  |                    |       |
   | private        | +     |         |                    |                    |       |
  
  *private*
  //private is import especially when multithreading.
  [[./Cp7_Private.java][Cp7_Private.java]]
  //getter/setter
  private String Xxx
  public String getXxx(){
    return XXX;
  }
  public String setXxx(String name){
    this.XXX = name;
  }

  *protected*
  //protected is to deal with inheritance.

  *default*
  //default package. i.e. classes in the same directory.

*** Interface and implementation
    *encapsulation*
    //convention: public at top.

    *Class level control*
    //Since a class cannot be private or protected, in case that want to limit class access,
    //use a private constructor. and a static method to call it.
    *method1* //useful if extra process needed, when creating an instance. Say a count.
    class Soup1 {
      private Soup1(){}
      public static Soup1 makeSoup(){
        return new Soup1();
      }
    }
    *method2* //a *design pattern*, <<Thinking in Patterns>>. It only allows one single object to be created.
    class Soup2 {
      private Soup2(){}
      //the "Singleton" pattern
      private static Soup2 ps1 = new Soup2(); 
      public static Soup2 access(){
        return ps1;
      }
      public void f(){}
    }

* Chapter 8, Reusing Classes
** Composition syntax
   in the book section, the code overwrited non-primitive object's *toString()* method.
   [[./Cp8_ToString.java][Cp8_ToString.java]]
   
//Mar 19, ~p168
** Inheritance syntax
   class sub-class extends super-class{}
   //if constructor *without* arguments.
   //the constructor will be called outward.
** Constructors without argument   
   [[./Cp8_ConstructorsWithoutArgument.java][Cp8_ConstructorsWithoutArguent]]

** Constructors with argument
   *super*
   [[./Cp8_Super.java::20][Cp8_Super.java::20]]
   //The *super* is just like *this*
   //super.methodA(); to call methodA() in super.
   
** Delegation
   public class SpaceShipControls{
     void up(int v){}
   }
   //delegation
   public class SpaceShip extends SpaceShipControls
     {public void up (int v){controls.up(v)}
   }

** Guaranteeing proper cleanup
   //If cleanup is necessary,
   //use 
   try{
     //...
   } finally {
     x.disposeFunction();//...
   }

** Name hiding @Override
   //To prevent unintentionally overloading in sub-classes.
   //Use the annotation. after Java SE5
   [[./Cp8_Override.java][Cp8_Override.java]]
   
//Mar 21, ~179
** protected
   [[./Cp8_Protected.java][Cp8_Protected.java]] 
   //the private field cannot be accessed even in sub-classes.
   //private field using set/get method.
   // *However a new private static int call with the same name will not override* see line 24

** Upcasting
   class Instrument {
     public void play(){}
     static void tune(Instrument i){
       // ...
       i.play();
     }
   }
   public class Wind extends Instrument{
     public static void main(String[] args){
       Wind flute = new Wind();
       Instrument.tune(flute); //Upcasting
     }
   }

   //Ask: do I need upcasting.
   //Upcasting(inheritance) or Composition?
   //in Polymorphism.

** *Final*
   Either a *compile-time constant* that won't ever change.
   Or can be a value initialized at run time that you don't want changed. (?) 
   
   *static final* has only one picece of storge that cannot be changed.
   //Naming convention: static final *ALL_CAPS_WITH_UNDERBARS*
   
   *final* primitive cannot be changed.
   *final* pointer cannot be pointing to other objects. Though the objects can be modified.
   [[./Cp8_Final.java][Cp8_Final.java]]
   
** Blank finals
   [[./Cp8_Final.java::8][Cp8_Final.java::Line8]]
   
** final argsList
   void f(final int i), then {i++} becomes illegal.
   //primaily used to pass data to anonymous inner classes.
   
** When to use *final methods*
   1. Only use it to *prevent inhiritage / override.*
   2. (Deprecated, esp. after the *Hotspot* engine) Before Java SE 5/6, increase efficiency in some situations. When compile, invoke *inline calls*, which replace the method call with a copy of the actual code. As a result, the overhead is eliminated.
   [[./Cp8_FinalMethods.java][Cp8_FinalMethods.java]]
   
** final classes
   cannot be inherited (extended).
   1. for Design reason.
   2. for Security reason.

*** the demerit of final.
    the Java 1.0/1.1 *Vector* class's methods are all final, which is bad. Due to:
    1. eliminated the possibility of overriding. e.g. the *Stack* inherit from *Vector*.
    2. inefficient when dealing with *Concurrency*. Because import methods, e.g. addElement(), elementAt(), are all synchronized. 
     
** Initialization and class loading
   different from C++, in Java, the static field's order does not matter.
   The loading start whenever a static member is accessed. 
   All constructors are by default static.
   So when a new constructor is called, the class code is loaded.
   Loading also happens when other static methods or field is called.
   And the initialization happends only once.

//Mar 27, ~p189
** Initialization with inheritance
   [[./Cp8_ConstructorsWithoutArgument.java::5][Cp8_ConstructorsWithoutArguent::5]]
   //Mind the Order. 
   [[./Cp8_CompileOrder.java][Cp8_CompileOrder.java]]
   
   1. The main function first
   2. The constructor, parents first
   3. other fields are load on call.
   //The behavoir varies, depends on compiler versions.
   
* Chapter 9, Polymorphism
  *decoupling different types*
  This is also called *dynamic binding, or late binding, or run-time binding*
  
** Upcasting
   [[./Cp9_PolyUpcasting.java][Cp9_PolyUpcasting.java]]
   *Once override, the Super method cannot be called. Any call would redirect to the method in the sub-class.*
   
** Binding
   [[./Cp9_PolyUpcasting.java::21][Cp9_PolyUpcasting.java::21]]
   //tune(Instrument i); How compiler knows the right class to point to?
*** Binding
    *dynamic binding, or late binding, or run-time binding*
    //in contract, C only have early binding
    All methods in JAVA are latebinding.
    Except static, final(or private which is implicitly final)
    
    So the *final* call turn off dynamic binding, thus prevent method being overridden.
    
*** Producing the right behavior
    //Shape-Circle situation
    *Shape s = new Circle();* 
    s.draw(); //Circle.draw() will be called.
    //And s.getClass() returns "Circle"
    [[./Cp9_Shape.java][Cp9_Shape.java]]
    //However, if a new method is decleared in sub-class, it may not behave as expected.
    //The base class must have all methods/interfaces

*** Pitfall: fields and static method
    [[./Cp9_PolyPitfall.java][Cp9_PolyPitfall.java]]
    *static field should be accessed in a static way*
    //Avoid this:
    //Super sup = new Sub();
    //sup.function();
    //When function is called:
    //1. check if the f() is overrided. Execute the overrided version.
    //2. The function is hard-coded in the Sub .class file. Hence it uses that namespace. 
    //3. While the static field, doesn't change. So sup.i returns base While the static field, doesn't change. So sup.i returns base static vWhile the static field, doesn't change. So sup.j returns base static value.lue.
    
*** Behavior of polymorphic methods inside constructor
    //Inheritance. Just like the *constructors*. 
    //If not default(gbc), remember the *base-class* version. i.e. the *super* version.
    //Othewise the super part could not be properly set-up/clean-up.
    //practically used in *shared objects*
    [[./Cp9_Operators2.java][Cp9_Operators2]]
//Apr 4, p211

*** Covariant return types
    //Should be samed as the section above. sup sub01 behavior different before Java SE5.

** Designing with inheritance
   //When to avoid using polymorphism.
   //Better to *use composition first* since it is more flexible.
   //the *"State"* design pattern.
   [[./Cp9_State.java][Cp9_State.java]]
   
   
*** Substitution vs Extension
    //A clear way to use inheritance(or *polymorphism*), is when "pure" inheritance happens.
    //That is, only methods already decleared are overridden, no more new methods are included.
    //Extends is useful, but in the following case the poly cannot access new methods in child.
    [[./Cp9_Extends.java::17][Cp9_Extends.java::17]]

** *ClassCastException*, when error in downcasting.
   // *runtime type identification(RTTI)*
   [[./Cp9_RTTI.java::29][Cp9_RTTI.java::29]]
   //baseClass x = new baseClass();
   //In this case x cannot be downcast

* Chapter 10, Interfaces
** Abstract classes and methods
   [[./Cp9_PolyUpcasting.java][Cp9_PolyUpcasting.java]]
   //The methods within the Instrument class is always dummy;
   //So the code can be wrote that, when those methods are called, generate errors;
   //But that requires run-time debugging.
   //In order to detect those error in compile time, use *abstract* keyword.
   *abstract void f();*
   | 1. abstract methods must be within abstract classes.      |
   | 2. abstract classes *could* contain non-abstract methods. |
   //the keyword prevent user from creating *new* object of that class directly.
   rewind: Cp7 Access Control:
   package com.package; //should be in .../com/package/ClassName.java
//Apr 6th, ~p220

** Interface
   //The *interface* keyword defines a completely abstract class.
   //In some other languages, this is called a "protocol"
   //Fields in an interface are implicitly *static* and *final*.
   [[./Cp10_Interface.java][Cp10_Interface.java]]
   
   | 1. All methods in an Interface are implicitly *public* only. | //void toString(); 
   | 2. The fields in an Interface is not implemented.            |
//Apr 9th, ~p225   

** *Complete decoupling*
   //When sub-function take different type of input, it does not Override super.
   [[./Cp9_Extends.java][Cp9_Extends.java]]
   class Processor {
     public String name(){ return getName(); }
     Object process(Object input) { return input; }
   }

   class Upcase() extends Processor { //body }

   public class Apply{
     public static void process(Processor p, Object s){ //p must be in a sub-class of class Processor.
       System.out.println(p.process(s));
     }
     public static void main(String[] args){
     process(new Upcase(), s);
     }
   }
   //When a Waveform which is a new package comes in, it cannot be used by Apply directly,
   //Since it is not a sub-class of class Processor.
   //The Processor and the Apply class are Not as decoupled.
   //Use interface to complete decouple as follows:

   public interface Processor {
     public String name();
     Object process(Object input);
   }

   class Upcase() implement Processor { //body }

   public class Apply{
     public static void process(Processor p, Object s){ //p could comes from anywhere outside the package.
       System.out.println(p.process(s));
     }
     public static void main(String[] args){
     process(new Upcase(), s);
     Waveform w = new Waveform();
     Apply.process(new FiterAdapter(new LowPass(1.0)), w); //And it could be more flexible.
     }
   }
   //Conclusion: Interface is more global, more flexible than an abstract class.

** "Multiple inheritance" in Java.
   //Interface is for *to upcast to more than one base type*.
   //Only 1 super class is allowed using *extends*
   //While Multiple interfaces are allowed using *implements*
   //implement vs abstract
   //1. use interface whenever can, whenever abstraction can be done without explicitly stating the function body or var.
   //2. to prevent client programming to new an "empty" object.
   
** Extending an interface with inheritance
   interface Monster{
     void meenace();
   }
   interface DangerousMonster extends Monster{
     void destroy();
   }
   interface Lethal {
     void kill();
   }
   interface Vampire extends DangerousMonster, Lethal {
   void drinkBlood();
   }
   //provide easy extenability

** Name collisions when combining interfaces
   class C{ public int f(){return 1}; }
   interface I { void f(); }
   //! C5 extends C implements I ; //error
   //return type different cannot differ methods away.
   // *Avoid same method names in different Interfaces.*

** Adapting to an interface
   //Scanner Java SE5 class.
   //by implementing method "read()", it is applicable to any existing class.

** Fields in interfaces 
   //Before Java SE5, the *enum* did not exist.
   //Hence:
   public interface Months{
     int
       JANUARY = 1, FEBRBUARY = 2, MARCH = 3,
       APRIL = 4, MAY = 5, JUNE = 6, JULY =7,
       AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
       NOVEMBER = 11, DECEMBER =12;
   }
   [[./Cp10_Months.java][Cp10_Months]]
   [[./Cp10_InterfaceAsEnum.java][Cp10_InterfaceAsEnum]]
   //Fileds cannot be *blank finals*

//Apr 13th, ~p236
** Nesting interfaces
   //It's a feature.

** Interfaces and factories
   // *Factory Method* designing pattern produce objects thta fit the interface.
   //commonly used in building *framework*.
   //More elegent using innerclass.
   
** Summary
   //Abstraction should be motivated by a real need.
   //Interfaces should be something that I refactor to when necessary, but not everywhere.
   //A guidline might be to *prefer classes over interfaces*, and use interface only when clearly necessary.

* Chapter 11, Inner Classes
  //Allow code to be more elegant and clear.
  //The difference against normal classes.
  | 1. names are nested within the parent                     |
  | 2. it can be written to linked to its *enclosing object*. |
  [[./Cp11_Selector.java][Cp11_Selector]] 
  //theSelector selector = sequence.selector();
  
** Using .this and .new
   [[./Cp11_DotNewThis.java][Cp11_DotNewThis]]
   public Cp11_DotNewThis getOuter() {
       return Cp11_DotNewThis.this;
   }
   dnI.getOuter().thisIS();
   
** Inner classes and upcasting
   //Could be used to hide implementations.
   //Since only Innner classes could be private or protected.

** Inner classes in methods and scopes
   //2 reasons for using the inner classes.
   | 1. to implement a a interface and returns a reference.             |
   | 2. as an assistant class locally, while solving a complex problem. |

   if(b){class x{//body, encapsulation & getter;}} 
   //then the code is not accessable outside the scope.
   
** ? Anonymous inner classes
   [[./Cp11_AnonymousInner.java][Cp11_AnonymousInner]]
   
** ? Factory Method revisited

** ? Nested classes

** Classes inside interfaces p257
   public interface C{
   void howdy();
   class Test implements C{
     System.out.println("Howdy");
   }
   public static void main(String[] args){
     new Test().howdy();
   }
}
   //as a static class. but nested. if inside a public class C, compiled as file: C$Tester, which could be deleted when packaging.

** Reaching outward from a multiply nested class.
   // *inner class object could call outer class private functions.*

** Why inner classes?
   //Must use: When multiple *abstract class* is wanted, to be extend.
   //Features: 
     //Each inner can *independently* inherit from an implementation.
       +Which means different implementations is possible within a single parent class.
       +Its creation not strictly tied to outer-class object. 
       +Which then provide better orginaziton. (The Sequence does not have to be a Selector. [[./Cp11_Selector.java][Cp11_Selector]])

#+NAME: multiple abstract class extensions
#+HEADERS: :classname C
#+BEGIN_SRC java
class ParentClass {} 
abstract class absC{
  void f(){
    System.out.println("absC.f");
  }
}
class Z extends ParentClass {
  absC makeC() {
    return new absC (){ 
      @Override
      void f() {
        System.out.println("absC.f.implement");
      }
    };
  }
} //anonymous inner class as an implementation
public class C{
  public static void main(String[] args){
    //! absC x = new absC(); //absC is abstract; cannot be instantiated
    Z z = new Z();
    z.makeC().f();
  }
}
#+END_SRC

#+RESULTS: multiple abstract class extensions
: absC.f.implement


** Closures & callbacks
   A *closure* is a callable object that retains information from the scope in which it was created.
     i.e. an inner class can manipulate private parameters in its parent class.

*** *callbacks* function implementation using inner class
    [[./Cp11_Callback.java][Cp11_Callback]]
#+NAME: Callback
#+HEADERS: :classname Cp11_Callback
#+BEGIN_SRC java
private class Closure implements Incrementable {
    public void increment() {
        Callee2.this.increment();
    }
}

Incrementable getCallbackReference() {
    return new Closure();
}

class Caller {
    //body...,
    //1.constructor with *Closure()* Object reference.
    //2.ref.increment() -> void go(){}
}
public class Cp11_Callback{
    public static void main(String[] args){
        Callee2 c2 = new Callee2();
        Caller caller = new Caller(c2.getCallbackReference());
        caller2.go();
    }
}
#+END_SRC

#+RESULTS: Callback
| 1 |
| 2 |

//It turned this.increment() into an Incrementable object.

** ? Inner classes & control frameworks
   
** ? Inheriting from inner classes
   //The super constructor must be explicitly called 
#+NAME: InheritInner
#+HEADERS: :classname InheritInner
#+BEGIN_SRC java
class A{
    class AInner { 
        int i;
        AInner(){
            i = 1;
            System.out.println("hi");
        }
    }
}
public class InheritInner extends A.AInner{
    //! InheritInner(){}
    InheritInner(A x){
        x.super(); //Though counter intuitive.
    }
    public static void main(String[] args){
        A xa = new A();
        InheritInner xaa = new InheritInner(xa);
        System.out.println(xaa.i);
        A.AInner xb = xa.new AInner();
        System.out.println(xb.i);
    }
}
#+END_SRC

#+RESULTS: InheritInner
| hi |
|  1 |
| hi |
|  1 |

** ? Local inner classes

* Chapter 12, Holding Your Objects (Container basic)
** Generics and type-safe containers
   [[./Cp12_ArrayListWithoutGeneric.java][Cp12_ArrayListWithoutGeneric]]
   [[./Cp12_ArrayListWithGeneric.java][Cp12_ArrayListWithGeneric]]
   //the ArrayList<Generic(class)> can also upcast, take sub-class Objects.
   //for(Apple c : apples)
         //loop body
** Basic concepts
   //Two very basic interfaces:
   1. Collection: a sequence of elements with rule(s) applied to them.
      + List: holds the order of elements inserted.
      + Set: cannot have duplicate elements
      + Queue: *produces* the elements in the order determined by a *queuing discipline*
   2. Map: a group of key-value object pairs, allowing value look-up with the key.
      + ArrayList: allows object look-up with *number*.
      + Map: allows look-up with *another object*. (also named as associatve array or a *dictionary*)
        
   //Upcasting also possible:
   List<Apple> apples = new ArrayList<Apple>();
   List<Apple> apples = new LinkedList<Apple>();
   //Though by upcasting, sub-type's specific functions might be lost.
   //e.g. TreeMap, LinkedList's functions that does not exist in Map, List.
   [[./Cp12_SimpleCollection.java][Cp12_SimpleCollection]]
   //0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
** Basic Methods; Adding groups of elements
   add(): ensures that this Collection contains the specified element.
   [[./Cp12_BasicMethods.java][Cp12_BasicMethods]]
   #+NAME: BasicMethods
   #+HEADERS: :classname 
   #+BEGIN_SRC java
   Collection<Integer> collection = new ArrayList<Integer>{Arrays.asList{1,2,3}}
   Collection<Integer> collection = new ArrayList<Integer>();
   Integer[] moreInts = {4,5,6};
   collection.addAll(Arrays.asList(moreInts)); //inferior
   Collections.addAll(collection, moreInts); //runs faster, hence the preferred approach
   #+END_SRC
   
   //the Arrays.asList() take a guess on type.
   [[./Cp12_AsListInference.java][Cp12_AsListInference]]
** Printing containers
   Arrays.toString()
   [[./Cp12_PrintingContainers.java][Cp12_PrintingContainers]]
   
#+NAME: PrintingContainers
#+HEADERS: :results table :classname PrintingContainers
#+BEGIN_SRC java
import java.util.*;

public class PrintingContainers {
    static Collection fill(Collection<String> collection) {
        collection.add("rat");
        collection.add("dog");
        collection.add("dog");
        return collection;
    }

    static Map fill(Map<String,String> map) {
        map.put("rat", "Fuzzy");
        map.put("dog", "Bosco");
        map.put("dog", "Spot");
        return map;
    }

    public static void main(String[] args) {
        System.out.println(fill(new ArrayList<String>()));
        System.out.println(fill(new LinkedList<String>()));
        System.out.println(fill(new HashSet<String>()));
        System.out.println(fill(new TreeSet<String>()));
        System.out.println(fill(new LinkedHashSet<String>()));
        System.out.println(fill(new HashMap<String,String>()));
        System.out.println(fill(new TreeMap<String,String>()));
        System.out.println(fill(new LinkedHashMap<String,String>()));
    }
}

#+END_SRC

#+RESULTS: PrintingContainers
| [rat       | dog        | dog] |
| [rat       | dog        | dog] |
| [rat       | dog]       |      |
| [dog       | rat]       |      |
| [rat       | dog]       |      |
| {rat=Fuzzy | dog=Spot}  |      |
| {dog=Spot  | rat=Fuzzy} |      |
| {rat=Fuzzy | dog=Spot}  |      |

   //HashSet Fastest to retrieve. If inserting order matters, 
   //LinkedHashSet or TreeSet(slower).
*** interface List extends Collection, Iterable
    //the List interface.
    //promise to maintain elements in a particular sequence.
    //Two types of List:
     + ArrayList: excels at random accesing elements, but slower when inserting and removing elements in the middle of a list.
     + LinkedList: provides optimal sequential access, insertion and deletion in the middle are cheaper, in exchange of a larger feature set than the ArrayList.
           //Maybe related to Type Information.
           
    //Basic methods:
    Obj.
        add(Obj); add(positionInIndex, Obj); addAll(positionInIndex, Obj); get(id); 
        remove(theExactObjRef); removeAll(); indexOf(theExactObj); clear();
        subList(idStart, idEnd); contains(Obj); set(id, Obj); 

    Collections.
        sort(Obj); Collections.shuffle(Obj); 
        
*** interface Iterator
#+BEGIN_SRC java
List<Pet> pets = new ArrayList<Pet>(Arrays.asList("dog", "cat"));
Iterator<Pet> it = pets.iterator();
#+END_SRC
    //it.
         hasNext(); next(); remove(); 
         
*** ListIterator
#+BEGIN_SRC java
List<Pet> pets = new ArrayList<Pet>(Arrays.asList("dog", "cat"));
Iterator<Pet> it = pets.listIterator();
#+END_SRC
    //it.
         hasNext(); next(); remove(); 
         
*** LinkedList 
#+BEGIN_SRC java
LinkedList<Pet> pets = new LinkedList<Pet>(Arrays.asList("dog", "cat"));
#+END_SRC
    //Obj.
          getFirst(); element(); peek(); removeFirst(); remove(); poll(); addfirst(); offer(); removeLast(); 

*** Stack
    //implemented using LinkedList.
    [[./Cp12_Stack.java][Cp12_Stack]]
    //To avoid conflict: must specify the whole path:
    //new java.util.Stack<String>();
    //new net.my.package.Stack<String>();
    
*** Set
    //
    
*** Map
    [[./Cp12_Map.java][Cp12_Map]]
    //Obj.
          put("key", Obj); get("key"); containsKey("key"); continsValue(Obj);
          
    //Multi-dimention
#+BEGIN_SRC java
public class MapOfList{
  public static Map<Person, List<? extends Pet>>
    petPeople = new HashMap<Person, List<? extends Pet>>();
  static {
    //...body
  }
  public static void main(String[] args) {
    System.out.println("People: " + petPeople.keySet());
    System.out.println("Pets: " + petPeople.values());
    for(Person person : petPeople.keySet()) {
      print(person + " has:")
      for(Pet pet : petPeople .get(person))
        print("    " + pet);
    }
  }
}
#+END_SRC

*** Queue
    //First-in, first-out
    //important in transfering objects from one area of a program to another.
    //important in Concurrency. 
    //Use LinkedList to implement a Queue through upcast.
    [[./Cp12_Queue.java][Cp12_Queue]]
    //Queue.
            offer(): instert to tail, return false if can't.
            peek(), element(): return head without removing. False / NoSuchElementException if empty.
            poll(), remove(): remove & return the head. null / NoSuchElementException if empty.
            
*** PriorityQueue
    //when offer(), obj is sorted into the queue, default using natural order;
    //The oreder can be modified by customizable *Comparator*;
    //Which changes the order, ensuring peek(), poll(), remove()
    
*** Collection vs Iterator
    //public class xxx extends AbstractCollection<Generic>;
    //then implement hasNext(); next();
   
*** Foreach and iterators
    for (Type t : obj) 
    //Works for all Iterable(After SE5) objects.
    //Two implementations:
    [[./Cp12_Foreach.java][Cp12_Foreach]]
  
**  The Adapter Method idiom
    //in case a reverse is needed.
    //instead of overriding the iterator() method,
    //write a function:
    [[./Cp12_Reversible.java][Cp12_Reversible]]
  
**  Summary
    1. Array can be multidimensional, and can hold primitives. However, size unchangable.
    2. Collection holds single elements, Map holds associated pairs. Resizable automatically. Won't hold primitives, but autoboxing possible.
    3. ArrayList if a lot of random access, while LinkedListif insert/remove in the middle.
    4. Queues and Stacks are implemented using LinkedList.
    5. Map associate Objects with Objects. HashMaps are designed for quick access, TreeMap keeps keys in sorted order, thus slower, while
       a LinkedHashMap keeps keys in insertion order, while provide rapid access.
    6. Set accepts one of each type of Object only. HashSets provide fast lookups, TreeSets keeps elements in sorted order, 
       LinkedHashSets keep elements in insertion order.
    7. no need to use the legacy classes Vector, Hashtable or Stack in new code.
       
    //Simple Container Taxonomy. p309
    
* Chapter 13, Error Handling with Exceptions
** Basic exceptions
   //exceptional condition -> a *new* exception object is created on the heap -> current path of execution is stopped ->
   the reference for the exception object is ejected -> exception-handling mechanism takes over and looking for the *exception hander* and execute.
** Exception arguments
   //throw new NullPointerException("t = null");
   //The string can be extracted.
   //Note that the *throw* can throw any type of *Throwable*.
** Catching an exception
   //a guarded region:
*** The try block 
#+BEGIN_SRC java
try {
    // Code that might generate exceptions.
} catch(Type1 id1)|{
    // Handle exceptions of Type1.
} catch(Type2 id2) {
    // Handler2
}
#+END_SRC
   //the id represents identifier.
**** Termination vs. resumption
     //for resumption, instead of throwing an exception, call a method that fixes the problem.
     //or put try inside a while loop.
     //However usually unpratical and hard to maintain especially in large systems, where the exception can be 
     //generated from many points.
** Creating customized exceptions
#+NAME: Cp13_InheritingExceptions
#+HEADERS: :results pp :classname InheritingExceptions
#+BEGIN_SRC java
class SimpleException extends Exception {}

public class InheritingExceptions {
    public void f() throws SimpleException{
        System.out.println("Throw SimpleException from f()");
        throw new SimpleException();
    }
    public static void main(String[] args){
        InheritingExceptions sed = new InheritingExceptions();
        try {
            sed.f();
        } catch(SimpleException e) {
            System.out.println("catch");
        }
    }
}
#+END_SRC

#+RESULTS: Cp13_InheritingExceptions
: Throw SimpleException from f()
: catch

   //printStackTrace(printStream);
   [[./Cp13_MyException.java][Cp13_MyException]]
   [[./Cp13_Logging.java][Cp13_Logging]]
Apr 19th, ~p321
** The exception specification
   //Must be thrown. 
   void function() throw exception;
   //However the throw can be compiled without really implementing a throw.
   //Thus, possible to throw in abstract classes.
** The *Exception* and how to catch'em all 
   [[./Cp13_AllException.java][Cp13_AllException]]
** The StackTrack Elements.
   [[./Cp13_StackTrace.java][Cp13_StackTrace]]
** Rethrowing an exception.
catch(Exception e) {
System.out.println("An exception was thrown.")
throw e;
}
   //Any further catch block for the Exception e will be ignored,
   //Meanwhile e will be thrown to exception handlers in the next higher context. 
   //its attributes and info remain *unchanged*. i.e. The original info is kept.
   //or also possible to overwrite the original using  method *fillInStackTrace()*.
   //or throw another class of exception to achieve the save effect.
** Exception chaining
   //After JDK 1.4, all *Throwable* have the option to take a *cause* object in their constructor. 
   //The *cause* is intended to be the originating exception.
   //In 3 fundamental exception classes, the *cause* argument is allowed in the *constructor*:
   | *Error*            | used by JVM to report system errors. |
   | *Exception*        |                                      |
   | *RuntimeException* |                                      |
   //to chain any other type of exceptions, use the *initCause()* method (inherited from the public class Throwable)
try {
     lowLevelOp();
 } catch (LowLevelException le) {
     throw (HighLevelException)
           new HighLevelException().initCause(le); // Which uses cast. Legacy constructor
 }
   [[./Cp13_MyException.java][Cp13_MyException]]
*** Multi-dimentional array
 [[./Cp0_Array3D.java][Cp0_Array3D]]
 arr03[0][1] = 4;
 arr03[0] = new int[] {2, 2};
 System.out.println((arr03[0][1]));
 //Output: 2
** Standard Java exceptions
   //java.lang.Exception, check oracle documentation
*** Special case: RuntimeException
    [[./Cp13_RuntimeException.java][Cp13_RuntimeException]]
    //RuntimeException is not required to be caught.
    //If it gets to main(),
    //printStackTrace() is called as the program exits.
    //Error messages are printed to System.err.
    //A RuntimeException means either:
      1. An error programmer cannot anticipate. e.g. a null pointer outside of the program.
      2. An error in the program. Such as an ArrayIndexOutOfBoundException.
** Performing cleanup with *finally*.
   *finally clause always run*.
   //example usage:
     1. As java's "goto" combined with the labeled break&continue statement.
     2. guarantee a important cleanup, which will be executed no matter what.  
        //e.g. use switch or if to implement multiple return point, finally use finally to cleanup.
*** pitfall: finally silence exception
    //Two situations:
    [[./Cp13_Pitfall.java][Cp13_Pitfall]]
    //a. Must ensure no exception is thrown in finally clause.
    //b. Must not have "return" in finally clause because it will mute all exceptions.
    // *Other situations*:
    try{
        f(); //report exception A.
        g(); //report exception B.
    } catch{//body} 
    //then exception B will not be reported if A error.
    
** Exception restrictions
   //When override a method, only exceptions that have been specified in the base class can be thrown.
   //An sub-class exception can be thrown.
   *Some advanced impromptu*:
   [[./Cp13_MyExceptionAdvanced.java][Cp13_MyExceptionAdvanced]]
   
** Constructors. Handle Construction Exceptions.
   //Sometimes, when constructor fail, the Obj won't be created, 
   //However finally runs every time, so it will run no matter what.
   //Use the following logic:
try{
    Construct x = new Construct(); // which may fail.
    try{
        // actions.
    } finally {
        x.dispose(); // clean-up if Obj x is constructed successfully.
    }
} catch (ConstructionException e) {
    // Construction Exception handler
}
   //Guard each Object if its construction may fail.

** Exception matching
   //As discovered in
   [[./Cp13_MyExceptionAdvanced.java][Cp13_MyExceptionAdvanced]]
   //Catch follows the order.
   
** Alternative approaches and guidelines
   //Some main logic of error handling:
   //Don't catch an exception unless know what to do with it.
   //The goal:
     1. To separate error handling code with main code, thus more readable.
     2. To reduce the amount of error-handling code, by allowing one handler to deal with multiple error sites.
   *to swallow the Exception:*
#+BEGIN_SRC java
try {
// ...body
} catch(ObligatoryException e) {} // Gulp!
#+END_SRC
   //Once this is done, the Exception is completly vanished.
   //Thus very hard to be re-discovered.
   //Remember to check.
   
** History
   //"...every invocation must be followed by a conditional test to determine what the outcome was.
   //This requirement leads to programs that are difficult to read, and probably inefficient as well,
   //thus discouraging programmers from signaling and handling exceptions."
   Thus one of the original motivation of exception was to prevent this requirement.
   //Authors reflection:
   //Error checking's merit comes from:
     1. A unified error-reporting model via exceptions.
        That is, regardless of whether the programmer is forced by the compiler to handle them.
     2. Type checking, regardless of *when* it takes place. 
        That is, either at compile time or at run time is fine.
        
   //Moreover, *reflection* and *generic* are required to compensate for the overconstraining nature of static typing.
   //Also, need to understand what the compiler is able to do.
   
** Passing exceptions to the console.
   [[./Cp13_ExceptionToConsole.java][Cp13_ExceptionToConsole]]
   // throw in main, which will be reflected in the console, does not require a catch.
   
** Converting checked to unchecked exceptions
try{
    // ... body
} catch(AnExceptionIDontKnowWhatToDo e){
    throw new RuntimeException(e);
}
   [[./Cp13_WrappedException.java][Cp13_WrappedException]]
   //Different types of exceptions are wrapped in a RuntimeException Object as its cause.
   //And since a RuntimeException does not require extra handling, more efficient.
   //Thus when do not know what to do, exception can be passed to someone who can handle it.
   
** Exception guideline:
   //Use exceptions to:
     1. Handle problems at the approatiate leve. (Avoid catching unless know what to do with them.)
     2. Fix the problem and call the method that cause the exception again.
     3. Patch things up and continue without retrying the method.
     4. Calculate some alternative result instead of what the method was suppose to produce.
     5. Do whatever you can in the current context and rethrow the *same* exception to a higher context.
     6. Do whatever you can in the current context and rethrow a *different* exception to a higher context.
     7. Terminate the program.
     8. Simplify. (Do not make things more complicated with the exception scheme.)
     9. Make your library and program safer. (Consider it as short-term investment for debugging, and a long-term investment for application robustness.)

** Summary
   //The actual recovery aspect might only be 10 percent.
   //However the bug reporting ablity is extremly useful. Even only with a Runtime exception.
//Apr 24th, ~p354
* Chapter 14, Strings
** Immutable Strings
   //String objects are immutable.
** Overloading '+' vs. StringBuilder
   //About Operator Overloading:
   //(The '+' and '+=' for *String* are the only operators that are overloaded in Java, and Java does not allow the programmer to overload any others.)
#+BEGIN_SRC java
String s = "abc" + "mango" + 47;
System.out.print(s);
//Output: abcmango47
#+END_SRC   
*** To decompile/disassemble the code: javap
    javap --help
    javap -c ClassName //Disassemble the code
[[./Cp14_SimpleStringV2.java][Cp14_SimpleStringV2]]
[[./Cp14_SimpleStringDisassembleV2][Cp14_SimpleStringDisassembleV2]]
//I think now instead of calling StringBuilder in Runtime, the String is resolved at compile time. 
//So that need no dynamic approach to reallocate the buffer.

[[./Cp14_SimpleString.java][Cp14_SimpleString]]
[[./Cp14_SimpleStringDisassemble][Cp14_SimpleStringDisassemble]]
    //Positional Order: 0, 1, 2, 3, ... 
| Afterline | Local Var | Stack    |
|         0 | 0 = this  | x        |
|         3 |           | x, x     |
|         4 |           | x        |
|         7 | 1 = x     |          |
|         9 | 2 = x     |          |
|        10 |           | x        |
|        11 |           | x.d      |
|        14 | 3 = x.d   |          |
|        16 |           | x, x     |
|        17 |           | x, x.d   |
|        25 |           | x, x.d++ |
|        28 |           |          |
|        31 |           | x.d      |
|        32 |           |          |
** StringBuilder
   //insert(), replace(), substring(), reverse()
   //append(), toString(), delete()
   [[./Cp14_BuildString.java][Cp14_BuildString]]
   //StringBuilder was introduced in JavaSE5. It's faster.
   //Before that *StringBuffer* was used, which ensured thread safety.
** Unintended recursion
   [[./Cp14_InfiniteRecursion.java][Cp14_InfiniteRecursion]]
   [[./Cp14_InfiniteRecursionDA][Cp14_InfiniteRecursionDA]]
   
   [[./Cp14_SimpleDeadLoop.java][Cp14_SimpleDeadLoop]]
   [[./Cp14_SimpleDeadLoopDA][Cp14_SimpleDeadLoopDA]]
   // return "AString" + this, in toString() implicitly calls the toString(), which causes the infinite recursion;
** Operations on Strings
** String format specifier
   [[./Cp14_Formatter.java][Cp14_Formatter]] 
   f.format("%-10.10s %5s %,20.2f\n", "Total", "", total);
   // %[argument_index$][flags][width][.precision]conversion
   //the .10 in the string means to truncate the string by that number.
*** a Hex Dumper
    //String.format(String format, Object... args)
    [[./Cp14_HexDumper.java][Cp14_HexDumper]]
** Regular Expression 
//the *Quantifiers*, p374.
| Greedy | Reluctant | Possessive | Matches                                 |
| X?     | X??       | X?+        | X, one or none                          |
| X*     | X*?       | X*+        | X, zero or more                         |
| X+     | X+?       | X++        | X, one or more                          |
| X{n}   | X{n}?     | X{n}+      | X, exactly n times                      |
| X{n,}  | X{n,}?    | X{n,}+     | X, at least n times                     |
| X{n,m} | X{n,m}?   | X{n,m}+    | X, at least n but not more than m times |
   
#+BEGIN_SRC java
System.out.println("+911".matches("(-|\\+)?\\d+")); // true
//------------
StringObj.split(regex); // split("n\\W+");
#+END_SRC
   //More in JDK documentation, section:
   java.util.regex.Pattern

*** Match in String
    [[./Cp14_MatchInString.java][Cp14_MatchInString]]
#+BEGIN_SRC java
    String s = "-1231234123";
    Pattern p = Pattern.compile("-\\d*");
    Matcher m = p.matcher(s);
    // m.reset("newString"); //reset() the Matcher m to new string. 
                             //m.reset(line); where (String line: new TextFile(args[0])){};
    System.out.println("maches(): " + m.matches()); // matches the whole string.
                                   // m.lookingAt() //matches from the start.
    while(m.find()){ //matches from anywhere.
        System.out.println(m.group() + " atpos: " + m.start() + "-" + (m.end() - 1));
    } 
#+END_SRC:

*** Groups
    [[./Cp14_RegexGroup.java][Cp14_RegexGroup]]

*** ? Pattern.flag
    
*** split()
    Arrays.toString(Pattern.compile("!!").split(input));
   
*** ? Replace operations
    //replaceFirst(); replaceAll(); appendReplacement(); appendTail();
    
** ? Scanning input p389
   [[./Cp14_SimpleRead.java][Cp14_SimpleRead]]
   //Scanner take a File Object, an InputStream, a String, or a Readable;
   [[./Cp14_Scanner.java][Cp14_Scanner]] 
   
*** ? StringTokenizer p389
    //to split string before scanner or split() exist in JDK.

* Chapter 15, Type Information
  //Runtime type infomation (RTTI) allows program to discover and use type information at runtime. 
** The need for RTTI
   psvm{
       List<Shape> shapeList = Arrays.asList(
           new Circle(), new Square(), new Triangle()
       );
       for(Shape shape : shapeList){
           shape.draw();
       }
   }
   //RTTI means that, at run time, the type of an object is identified.
   //RTTI routine:
     1. JVM load *Class object* using a subsystem named *class loader*.
     2. Which might comprise a chain of class loaders, however, only one *primordial class loader*.
     3. Which then loads *trusted classes*, including Java API classes, typically from the local disk, but can also include additional class loaders using hook, under special needs (e.g. related to Web server applications or downloading classes across a network).
     4. All classes are loaded into the JVM dynamically, upon the first time a static member of that class is referenced (the constructor is also a static method implicitly).
     5. The class loader first checks if the *Class* object for the specific type is loaded. If not, the default class loader finds the .class file by name (an add-on class loader might, e.g., look for the bytecodes in a database instead). As the bytes for that class are loaded, they are *verified* to ensure that they have not been corrupted and that they do not comprise bad Java code(one of the lines of defense for security in Java).
     6. Once the *Class* object for that type is in memory, it is used to create all objects of that type.
    //Class *Class*
    //Class.forName("X"); //returns the class object Class<?> X;

*** the Class object. Class.forName()
    [[./Cp15_forName.java][Cp15_forName]]
    //Reference to the appropriate *Class* object first, in order to use type information at run time.
    //2 convenient methods: 
      1. Class.forName("ClassName"). Which returns a reference to a particular class object.
      2. nameOfAnObj.getClass(). 
    //Literally, do not mix the two up. the returned classReference belongs to Class Class<T>

** Class literals ~p399
   

* Chapter 16,
* Chapter 17, Arrays
* Chapter 18, 
* Chapter 19, 
* Chapter 20, Annotations
* Chapter 21, Concurrency
  //speed vs. design manageablity
  //utilize multiple cores 
  //also may improve speed in single core processor (different from hyperthreading)
  // *blocking*, e.g. program stall during I/O.
  //Problem exists in dealing with global variables. need communication. (Go).
  //Language level: does function call produces side effects: *Erlang*
  
  //java threading creates tasks *whithin* the single process represented by the executing program.
          , ? which increase operating system transparency.(e.g.?)
            
  //The necessity of concurrency code designing:
      + To solve some particular problem, e.g. a simulation, in which the interaction among independent elements is necessary.
        Multithreaded systems often only support a relatively small number of threads, on the order of tens or hundreds. The number is platform dependent. in Java, it depends on the version of JVM.
        in Java, programmer should assume that threads number will not be large enough to assign one thread for each individual element.
        
  //A solution: 
    + *cooperative* multithreading. Each task voluntarily gives up control, which requires the programmer to consciously insert some kind of yielding statement into each task.
      Advantage: 
      | Context switching is typically much cheaper (than with a preemptive system)               |
      | ? Theoretically no limit to the number of independent tasks that can be running at once]. |
      //Hence, when dealing with a large number of simulation elements, this could be the ideal solution.                                                                            
      //However, some cooperative systems are not designed to distribute tasks across processors, which could be very limiting. (examples?)

    + Java: *preemptive* threading. scheduling mechanism provides time sices for each thread, periodically interrupting a thread and context switching to another thread so that each one is given a reasonable amount of time to drive its task.
      *messaging* system, when multiple independent computers distributed across a network exists. Then all the processes are running completely independently of each other,

** Basic threading
   //each of these independent tasks(subtasks) is driven by a *thread of execution*, which is a single sequential flow of control within a process. A single process can thus have multiple concurrently executing tasks. 
   //The CPU allocation is seperated in a different layer.

*** Defining tasks
    A Thread drives tasks, hence need a way to describe the task. Using *Runnable*.
    [[./Cp21_LiftOff.java][Cp21_LiftOff]]
    [[./Cp21_LiftOffRun.java][Cp21_LiftOffRun]]

*** The *Thread* class
    [[./Cp21_LiftOffBasicThreads.java][Cp21_LiftOffBasicThreads]] 
    Thread t = Thread(Runnable);
    t.start(); // start(), when called, JVM calls the run() method of this thread.
    [[./Cp21_LiftOffMoreBasicThreads.java][Cp21_LiftOffMoreBasicThreads]] 
    //About public static void Thread.yield();
        + This method is rarely approprite to use. However may be useful for debugging or testing, where it may help to reproduce bugs due to race conditions.
    //About GBC:
        main{
            new Thread(Runnable).start();
        }

        + Though it seems no reference is generated when a new thread is called, and thus might be GBCed, it is not. *Each Thread has a reference stored somewhere, and cannot be cleaned up ultil the task exits its run() and dies*. 
     [[./Cp21_Print3TimesReturn.java][Cp21_Print3TimesReturn]]
     

** Using Executors
   //Java SE5 java.util.concurrent *Executors*
   public interface Executor throws RejectedExcecutionException, NullPointerException{
       void execute(Runnable command);
   }
   //The interafce provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use scheduling, etc.
       //Usage: Instead of
           new Thread(new(RunnableTask())).start();
       //use the following:
           Executor executor = anExecutor;
           executor.execute(new RunnableTask1());
           executor.execute(new RunnableTask2());
           [[./Cp21_ExecutorDirect.java][Cp21_ExecutorDirect]]

#+BEGIN_SRC java
import java.util.concurrent.*;
public class anExecutor01 implements Executor {
    public void execute(Runnable r) {
        r.run();
    }
}
public class anExecutor02 implements Executor {
    public void execute(Runnable r) {
        new Thread(r).start();
    }
}
#+END_SRC
    //Class Structure:
    + class Executors: 
        - static ExecutorService newCachedThreadPool();
        - static ExecutorService newCachedThreadPool(ThreadFactory threadFactory);
    + Interface ExecutorService extends Executor:
        - void execute();
      
